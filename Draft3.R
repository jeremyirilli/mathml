# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit Draft3.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
# To do
#
# paste(x, y, z)
# Spacing
# Comma separated lists
# Ellipsis
# Radicals
# Subsets
# Greek letters in MathJax
# Typeface
# Stylechanges
# Phantoms

library(plotly)
library(ggplot2)

mathout <- function(...)
{
  if(knitr::is_html_output())
    return(mathml(...))

  if(knitr::is_latex_output())
    return(mathjax(...))

  warning("no output specified")  
  mathjax(...)
}

catmath <- function(term, ...)
{
  s <- substitute(term)
  mathout(canonical(s), ...)
}


## ---- echo=TRUE, results='asis'-----------------------------------------------
library(rolog)
library(mathml)
term = quote(pbinom(k, N, p))

# Pretty print
mathout(term)


## ---- results = 'asis', echo = TRUE-------------------------------------------
k = 10
N = 22
p = 0.4
eval(term)


## ----  results = 'asis', echo = TRUE------------------------------------------
term = quote(integrate(sin, 0L, 2L*pi))
mathout(term)


## ---- echo = TRUE-------------------------------------------------------------
eval(term)


## ---- echo=TRUE, results='asis'-----------------------------------------------
# A custom function
g <- function(u)
{
  sin(u)
}

# Mixture of (partially) named and positional arguments in unusual order
term = call("integrate", lower=-Inf, upper=Inf, g)
attributes(term)$name = quote(g)
mathout(canonical(term))

# Even more complex
term <- call("*", 2L, call("$", call("integrate", low=-Inf, up=Inf, g), "value"))
attributes(term)$name = quote(g)
mathout(canonical(term))

# It is a bit of a mystery that R knows the result of this integral.
eval(term)


## ---- echo=TRUE---------------------------------------------------------------
# Improve display
hook(quote(mu_A), quote(mu["A"]))
hook(quote(mu_B), quote(mu["B"]))
hook(quote(sigma_A), quote(sigma["A"]))
hook(quote(sigma_B), quote(sigma["B"]))
hook(quote(mu_M), quote(mu["M"]))
hook(quote(zn), quote(z[tau]))
hook(quote(M), quote(overline(X)))


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(x + y - z)


## ---- results='asis', echo=TRUE-----------------------------------------------
# Note wrong precedence of custom operator
catmath(mean(m) %+-% 1.96 * s/sqrt(N))


## ---- results='asis', echo=TRUE-----------------------------------------------
# This is what we actually want
catmath(mean(m) %+-% (1.96 * s/sqrt(N)))

# Without parentheses
catmath(mean(m) %+-% {1.96 * s/sqrt(N)})


## ---- results='asis', echo=TRUE-----------------------------------------------

catmath(x*y)

catmath(x %*% y)

catmath(x %.% y)

catmath(X %x% Y)

catmath(x/y)

catmath(x %/% y)


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(a["x"])

catmath(a^x)

catmath(x["b"]^"a")


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(frac(x, y))

catmath(over(x, y))

catmath(choose(n, k))

catmath(lchoose(n, k))


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(sqrt(x))


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(x==y)

catmath(x < y)

catmath(x <= y)

catmath(x >= y)

catmath(!x)

catmath(x != y)

catmath(X ~ Y)

catmath(x %~~% y)

catmath(x %==% y)

catmath(x %=~% y)

catmath(x %prop% y)


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(a %in% A)

catmath(intersect(A, B))

catmath(union(A, B))

catmath(is.null(intersect(A, B)))


## ---- results="asis", echo=TRUE-----------------------------------------------
# x %<->% y
catmath(x %<->% y)

# x %->% y
catmath(x %->% y)

# x %<-% y
catmath(x %<-% y)

# x %up% y:
catmath(x %up% y)

# x %down% y:
catmath(x %down% y)

# x %<=>% y: solved it using iff
catmath(x %<=>% y)

# x %=>% y: solved using rArr
catmath(x %=>% y)

# x %<=% y: solved using lArr
catmath(x %<=% y)

# x %dblup% y:
catmath(x %dblup% y)

# x %dbldown% y:
catmath(x %dbldown% y)


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(hat(x))

catmath(hat(xy))

catmath(mean(x))

catmath(mean(xy))


## ---- results="asis", echo=TRUE-----------------------------------------------
catmath(A-Omega)

catmath(alpha-omega)

catmath(pi-Pi)

catmath(Inf)


## ---- results='asis', echo=TRUE-----------------------------------------------
catmath(sum(x[i], i==1L, n))

# fixme: braces not needed when right to *
catmath(a * sum(b))

# Multiplication (capital Pi) is missing
catmath(a * prod(b))

catmath(integrate(sin, 0L, 2L*pi))

catmath(A & B)

catmath(A | B)

catmath(!A)

catmath(xor(A, B))

catmath(exp(2L*pi*i))

catmath(expm1(2L*pi*i))

catmath(log(x))

catmath(log10(x))

catmath(log2(x))

catmath(logb(x, e))

catmath(log1p(x))

catmath(ceiling(pi))

catmath(floor(pi))

catmath(sin(pi/2L))

catmath(cos(pi/2L))

catmath(tan(pi/2L))


## ---- results='asis', echo=TRUE-----------------------------------------------
first <- quote(a)
second <- quote(b + c)
mathout(call("*", first, second))

# precedence
quote(a * (b + c))[[3]][[1]]


## ---- results='asis', echo=TRUE-----------------------------------------------
catmath(x^y + z)

# mathout(call("+", call("^", as.symbol("x"), as.symbol("y")), as.symbol("z")))

catmath(x^(y + z))


## ---- results='asis', echo=TRUE-----------------------------------------------
# without parenthesis
mathout(canonical(call("^", as.symbol("x"), call("+", as.symbol("y"), as.symbol("z")))))

# shortcut
catmath(x^{y + z})


## ---- results='asis', echo=TRUE-----------------------------------------------
catmath(abs(x))


## ---- results='asis', echo=TRUE-----------------------------------------------
vec <- 1:3
mathout(canonical(vec))
mathout(vec)

mat <- matrix(data = c(2L, 3L, 4L, 5L), nrow = 2, ncol = 2)
mathout(canonical(mat))


## ---- results='asis', echo=TRUE-----------------------------------------------

hook(quote(x_1), quote(mean(x["1"])))
hook(quote(x_2), quote(mean(x["2"])))
hook(quote(n_1), quote(n["1"]))
hook(quote(n_2), quote(n["2"]))
hook(quote(s_1), quote(s["1"]))
hook(quote(s_2), quote(s["2"]))
hook(quote(s_p), quote(s["pool"]))


t <- quote(dfrac(x_1 - x_2, sqrt(denote(s_p^2L, frac((n_1 - 1L)*s_1^2L + (n_2 - 1L)*s_2^2L, n_1+n_2-2L), "the pooled variance.") * (dfrac(1L, n_1)+dfrac(1L,n_2)))))
  
mathout(t)

# An example

x_1 = 20.5
x_2 = 35.7
n_1 = 150
n_2 = 160
s_1 = 3.4
s_2 = 4.2

eval(t)


## ---- results="asis", echo=TRUE-----------------------------------------------
f <- function(tau, c, mu_A, sigma_A, mu_B, sigma_B)
{ dfrac(c, mu_A) + (dfrac(1L, mu_A) - dfrac(1L, mu_A + mu_B)) *
    ((mu_A*tau - c) * pnorm(dfrac(c - mu_A*tau, sqrt(sigma_A^2L*tau)))
      - (mu_A*tau + c) * exp(dfrac(2L*mu_A*c, sigma_A^2L))
        * pnorm(dfrac(-c - mu_A*tau, sqrt(sigma_A^2L*tau))))
}

mathout(f)


## ---- echo=FALSE--------------------------------------------------------------
mu_A = 0.53
mu_B = 1.32
sigma_A = 4.4
sigma_B = 18.3
tau = c(-Inf, -167, -133, -100, -67, -33, 0, 33, 67, 100, 133, 167, Inf)
c = 100
mu_M = 161


## ---- results="asis", echo=FALSE----------------------------------------------
# Conditions

g <- function(tau, c, mu_A, sigma_A, mu_B, sigma_B)
{
    if( tau == Inf) return(dfrac(c, mu_A));
    if( tau == -Inf) return(dfrac(c, mu_B));
    if( tau > 0L)  return(f(tau, c, mu_A, sigma_A, mu_B, sigma_B));
    if( tau == 0L) return(dfrac(c, mu_A + mu_B));
    if( tau < 0L) return(f(-tau, c,  mu_B, sigma_B, mu_A, sigma_A))
}

mathout(g)


## ---- echo=FALSE--------------------------------------------------------------
mu_A = 0.53
mu_B = 1.32
sigma_A = 4.4
sigma_B = 18.3
tau = -167
c = 100
mu_M = 161

g(tau, c, mu_A, sigma_A, mu_B, sigma_B)


## ---- echo=FALSE--------------------------------------------------------------
g(tau, c, mu_A, sigma_A, mu_B, sigma_B) + mu_M


## ---- results="asis", echo=FALSE----------------------------------------------

G <- Vectorize(g, vectorize.args = 'tau')

h <- function(tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
{
  G(tau, c, mu_A, sigma_A, mu_B, sigma_B) + mu_M
}

mathout(h)


## ---- echo=FALSE--------------------------------------------------------------

mu_M = 161
mu_A = 0.53
mu_B = 1.32
sigma_A = 4.4
sigma_B = 18.3
tau = c(-Inf, -167, -133, -100, -67, -33, 0, 33, 67, 100, 133, 167, Inf)
c = 100

h(tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)


## ---- results="asis", echo=FALSE----------------------------------------------
zf <-  function(M, s, N, tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
{
  E <- h(tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
  dfrac(M-E, s/sqrt(N))
}

mathout(zf)


## ---- echo=FALSE--------------------------------------------------------------
# The vector X contains the observed values, the vector s their observed standard deviation and N = 400 are the number of trials.

M = c(231, 234, 230, 227, 228, 221, 217, 238, 263, 277, 298, 316, 348)
s = c(56, 58, 40, 40, 32, 28, 28, 28, 26, 30, 32, 34, 92)
N = c(400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400)

zn <- zf(M, s, N, tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
zn


## ---- results="asis", echo=FALSE----------------------------------------------
par <- c(mu_A = 0.53, sigma_A = 4.4, mu_B = 1.32, sigma_B = 18.3, mu_M = 161)

# Goodness of Fit

gof <- function(par, tau, M, s, N)
{
  zn <- zf(M, s, N, tau, c=100L, mu_A=par["mu_A"], sigma_A=par["sigma_A"], mu_B=par["mu_B"], sigma_B=par["sigma_B"], mu_M=par["mu_M"])
  sum(zn^2L)
}

mathout(gof)


## ---- results="asis", echo=FALSE----------------------------------------------
n <- gof(par, tau, M, s, N)
n
pchisq(n, 8, lower.tail = FALSE, log.p = FALSE)


## ---- results="asis", echo=FALSE----------------------------------------------
lsq = function(tau, M, s, N)
{
  start = c(mu_A = 0.3, sigma_A = 2, mu_B = 1 , sigma_B = 5, mu_M = 200)
  optim(start, fn = gof,
    tau = tau, M = M, s = s, N = N, hessian = TRUE, control = list(fnscale = 1))
}

mathout(lsq)

# Parameters' estimates
fit <-  lsq(tau, M, s, N)

est = fit$par
se = sqrt(diag(solve(fit$hessian)))
cilo = qnorm(0.025, est, se)
ciup = qnorm(0.975, est, se)

# Lower bound
#cilo

# Upper bound
#ciup



## ---- results="asis", echo=TRUE-----------------------------------------------
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"]) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))))
}

attributes(f)$name = quote(f)
mathout(f)


## ---- results="asis", echo=TRUE-----------------------------------------------
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"])) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau))))
}

attributes(f)$name = quote(f)
mathout(f)


## ---- results="asis"----------------------------------------------------------
t <- quote(omit_left(a + b))
mathout(t)


## ---- results="asis"----------------------------------------------------------
t <- quote(omit_right(a + b))
mathout(t)


## ---- results="asis"----------------------------------------------------------
t <- list(quote(a), quote(b), quote(omit(c)))
mathout(t)


## ---- results="asis"----------------------------------------------------------
t <- quote(add_left(a + b))
mathout(t)


## ---- results="asis"----------------------------------------------------------
t <- quote(add_right(a + b))
mathout(t)


## ---- results="asis"----------------------------------------------------------
t <- list(quote(a), quote(b), quote(add(c)), quote(d))
mathout(t)


## ---- results="asis"----------------------------------------------------------
t <- quote(instead(a, b) + c)
mathout(t)


## ---- results="asis"----------------------------------------------------------
# It highlights what has been omitted
t <- quote(omit_left(a + b))
mathout(t, flags=quote(error(highlight))) # default


## ---- results="asis"----------------------------------------------------------
# It prints the correct version
mathout(t, flags=quote(error(ignore)))


## ---- results="asis"----------------------------------------------------------
# It prints the correct version
mathout(t, flags=quote(error(asis)))


## ---- results="asis"----------------------------------------------------------
# It highlights the correct version by framing it
mathout(t, flags=quote(error(fix)))


## ---- results="asis"----------------------------------------------------------
# It frames the redundant term
t <- quote(add_right(a + b))
mathout(t, flags=quote(error(highlight))) # default


## ---- results="asis"----------------------------------------------------------
# It prints the correct expression without the redundant term
mathout(t, flags=quote(error(ignore)))


## ---- results="asis"----------------------------------------------------------
# It strikes the redundant term 
mathout(t, flags=quote(error(fix)))


## ---- results="asis"----------------------------------------------------------
# It highlights that a is wrong and b is correct
t <- quote(instead(a, b) + c)
mathout(t, flags=quote(error(highlight))) # default


## ---- results="asis"----------------------------------------------------------
# It provides the correct solution
mathout(t, flags=quote(error(ignore)))


## ---- results="asis"----------------------------------------------------------
# It provides the correct solution framing the correct term
mathout(t, flags=quote(error(fix)))

