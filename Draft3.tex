% !TeX root = RJwrapper.tex
\title{mathml: Translate R expressions to MathML and LaTeX/MathJax}
\author{by Matthias Gondan and Irene Alfarone}

\maketitle

\abstract{%
This R~package translates R~objects to suitable entities in MathML or LaTeX, thereby enabling pretty mathematical representation of R~functions or algorithms in data analysis, scientific reports and interactive web content. R~code text descriptions and mathematical content already coexist, side-by-side, in the RMarkdown document rendering language. The present package allows to use the same R~objects for both data analysis and typesetting in documents or web content. By tightening the link between the statistical analysis and its verbal or symbolic representation, this new feature is a futher step towards reproducible science. User-defined hooks allow to extend the package by mapping new variable names and functions to new MathML and LaTeX entities. We provide a few working examples that illustrate the use of the package in a little scientific report and in an interactive web page.
}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

The R extension of the markdown language (Xie, Dervieux, and Riederer 2020) enables reproducible
statistical reports with nice typesetting in HTML, Microsoft Word, and Latex.
Since recently (R Core Team 2021, version 4.2), R's manual pages include support for
mathematical expressions (Sarkar and Hornik 2022), which already is a big improvement.
However, rules for the translation of R's built-in language elements to their
mathematical representation are still lacking. So far, R expressions such
as \texttt{pbinom(k,\ N,\ p)} are printed as they are; pretty mathematical formulae
like \(P_\mathrm{Bi}(X \le k; N, p)\) require explicit Latex commands, that
is, \texttt{P\_\textbackslash{}mathrm\{Bi\}\textbackslash{}left(X\ \textbackslash{}le\ k;\ N,\ p\textbackslash{}right)}. Except for minimalistic examples,
these commands are tedious to type in and hard to read in their source code.

The present R package defines a set of rules for an \emph{automatic} translation of
R expressions to mathematical output in RMarkdown documents (Xie, Dervieux, and Riederer 2020) and
ShinyApp webpages (Chang et al. 2022). The translation is done by an embedded Prolog
interpreter that maps nested expressions recursively to MathML and
LaTeX/MathJax, respectively. User-defined hooks enable to extend the set of
rules, for example, to represent specific R elements by custom mathematical
signs.

\emph{todo}: mention that the \emph{same} R expression is used for mathematical
calculations and printing.

The paper is organized as follows. Section~2 presents the background of the
package, including Prolog and the R package \pkg{rolog} and the two main classes
of rules for translating R~objects to mathematical expressions. Section~3
illustrates some important features of the \pkg{mathml} package, potential
issues and workarounds using examples from the day-to-day perspective of the
user. Sections~4 and~5 present two case studies for the use of the package in
a scientific report and a ShinyApp web page. Section~6 concludes with a
discussion and ideas for further development. A complete list of the R elements
covered by the package is found in the Appendix.

\hypertarget{background}{%
\section{Background}\label{background}}

\hypertarget{prolog-the-package}{%
\subsection{\texorpdfstring{Prolog: the \pkg{rolog} package}{Prolog: the  package}}\label{prolog-the-package}}

The automatic translation of R expressions to mathematical output is achieved through a Prolog interpreter. Prolog is a classical logic programming language with many applications in expert systems, computer linguistics and traditional, that is, symbolic artificial intelligence. The main strength of Prolog is its concise representation of facts and rules for the representation of knowledge and grammar, as well as its efficient built-in search engine for closed world domains. R, as it is well-known, is a statistical programming language for data analysis and statistical modeling which is widely used in academia and industry. Besides the core library, a lot of packages have been developed for all kinds of statistical problems, including statistics-based artificial intelligence tools such as neural networks for machine learning and deep learning. Whereas Prolog is weak in statistical computation, but strong in symbolic manipulation, the converse may be said for the R language. The \pkg{rolog} package then bridges this gap by providing an interface to a SWI-Prolog distribution in R. The communication between the two systems is mainly in the form of queries from R to Prolog, but two predicates allow Prolog to ring back and evaluate terms in R.
Here is reported a first trivial example. At the Prolog end, there is a handler for \texttt{pbinom/3} that translates the term into a pretty MathML syntax like P\_bi(X \textless= k; N, pi).

\begin{verbatim}
library(rolog)
\end{verbatim}

\begin{verbatim}
#> Found SWI-Prolog at SWI_HOME_DIR: /Library/Frameworks/R.framework/Versions/4.2/Resources/library/rswipl/swipl/lib/swipl
\end{verbatim}

\begin{verbatim}
#> Welcome to SWI-Prolog (threaded, 64 bits, version 8.5.20)
#> SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
#> Please run ?- license. for legal details.
#> 
#> For online help and background, visit https://www.swi-prolog.org
#> For built-in help, use ?- help(Topic). or ?- apropos(Word).
\end{verbatim}

\begin{verbatim}
library(mathml)
term = quote(pbinom(k, N, p))

# Pretty print
mathout(term)
\end{verbatim}

\({{{P}_\mathrm{Bi}}\left({{{X}\le{k}}{;{{N}{,{p}}}}}\right)}\)

Beside the graphical rendition of the term, an important feature is that the package allows also for its calculation, for example:

\begin{verbatim}
k = 10
N = 22
p = 0.4
eval(term)
\end{verbatim}

{[}1{]} 0.77195

Here we present a second less trivial example where Prolog needs to find out the name of
the integration variable for \texttt{sin}. For that purpose, \pkg{rolog} provides a predicate \texttt{r\_eval/2} that calls R from Prolog. Here, the predicate is used for the R~function \texttt{formalArgs(args(sin))}, which returns the name of the function argument of \texttt{sin}, that is, \texttt{x}.

\begin{verbatim}
term = quote(integrate(sin, 0L, 2L*pi))
mathout(term)
\end{verbatim}

\(\int_{{0}}^{{{2}{}\pi}}{{\sin{x}}}\,{d{x}}\)

\begin{verbatim}
eval(term)
\end{verbatim}

\begin{verbatim}
#> 2.221501e-16 with absolute error < 4.4e-14
\end{verbatim}

Note that, on the Prolog end, the handler for \texttt{integrate/3} is rather rigid; it
accepts only these three arguments in that particular order, and without names,
that is, \texttt{integrate(sin,\ lower=0L,\ upper=2L\ *\ pi)}, would not print the desired
result.

Therefore, \texttt{pl/mathml.pl} includes two handlers that accept terms with named
arguments, \texttt{integrate(f=Fn,\ lower=Lower,\ upper=Upper)}, as well as terms of the
form \texttt{\$(integrate(Fn,\ Lower,\ Upper),\ value)} that are needed for the evaluation
below.

\begin{verbatim}
# A custom function
g <- function(u)
{
  sin(u)
}

# Mixture of (partially) named and positional arguments in unusual order
term = call("integrate", lower=-Inf, upper=Inf, g)
attributes(term)$name = quote(g)
mathout(canonical(term))
\end{verbatim}

\(\int_{{-\infty}}^{\infty}{{{g}\left({u}\right)}}\,{d{u}}\)

\begin{verbatim}
# Even more complex
term <- call("*", 2L, call("$", call("integrate", low=-Inf, up=Inf, g), "value"))
attributes(term)$name = quote(g)
mathout(canonical(term))
\end{verbatim}

\({{2}\cdot\int_{{-\infty}}^{\infty}{{{g}\left({u}\right)}}\,{d{u}}}\)

\begin{verbatim}
# It is a bit of a mystery that R knows the result of this integral.
eval(term)
\end{verbatim}

{[}1{]} 0

The extra R function \texttt{canonical()} applies \texttt{match.call()} to non-primitive R
calls, basically cleaning up the arguments and bringing them into the correct
order.

\hypertarget{package-capabilities}{%
\section{Package capabilities}\label{package-capabilities}}

\pkg{mathml} is a package for pretty mathematical representation of R functions or algorithms in data analysis, scientific reports and interactive web content. The features currently supported are listed below, following the order proposed by (Murrell and Ihaka 2000).

\hypertarget{hooks}{%
\subsection{Hooks}\label{hooks}}

Before start listing all the possible operations with \pkg{mathml}, we mention here that \pkg{mathml} also allows the user to create hooks for specific functions. As an example:

\begin{verbatim}
# Improve display
hook(quote(mu_A), quote(mu["A"]))
hook(quote(mu_B), quote(mu["B"]))
hook(quote(sigma_A), quote(sigma["A"]))
hook(quote(sigma_B), quote(sigma["B"]))
hook(quote(mu_M), quote(mu["M"]))
hook(quote(zn), quote(z[tau]))
hook(quote(M), quote(overline(X)))
\end{verbatim}

The hooks reported here will be the one used in Section \emph{ref} to display the equations in the Case Study. On the right hand side of the parenthesis is reported the way that the variable, for instance

\hypertarget{arithmetic-operators}{%
\subsection{Arithmetic operators}\label{arithmetic-operators}}

The \pkg{mathml} package provides the graphical representation for addition, subtraction, multiplication and division. For instance:

\begin{verbatim}
catmath(x + y - z)
\end{verbatim}

\({{{x}+{y}}-{z}}\)

In addition, with \pkg{mathml} it is also possible to combine \texttt{minus} and \texttt{plus} and get a new operator. However, in R~the operator \(\pm\) is not present and this leads to some interesting questions. If we let R~present the expression, this is what we get:

\begin{verbatim}
# Note wrong precedence of custom operator
catmath(mean(m) %+-% 1.96 * s/sqrt(N))
\end{verbatim}

\({{\left({\overline{{m}}\pm{1.96}}\right)\cdot{s}}/\sqrt{{N}}}\)

As can be seen, the new custom operator takes precedence over multiplication, as R~automatically puts \texttt{mean(m)\ \%+-\%\ 1.96} in parentheses. Unfortunately, this is not consistent with the rules of mathematics. As the reader well knows, it is not possible in R~to change the precedence of custom operators. This leaves two possible solutions. The first involves a mathematically unnecessary parenthesis around \texttt{(1.96\ *\ s/sqrt(N))}. The second is more elegant and mathematically consistent: here \texttt{1.96\ *\ s/sqrt(N)} is put in curly brackets and mathematical formality is respected. In both solutions R~is able to produce correct output once the order of operations is made explicit.

\begin{verbatim}
# This is what we actually want
catmath(mean(m) %+-% (1.96 * s/sqrt(N)))
\end{verbatim}

\({\overline{{m}}\pm\left({{{1.96}{}{s}}/\sqrt{{N}}}\right)}\)

\begin{verbatim}
# Without parentheses
catmath(mean(m) %+-% {1.96 * s/sqrt(N)})
\end{verbatim}

\({\overline{{m}}\pm{{{1.96}{}{s}}/\sqrt{{N}}}}\)

\emph{The following can be inserted in a table}

\begin{verbatim}
catmath(x*y)
\end{verbatim}

\({{x}{}{y}}\)

\begin{verbatim}
catmath(x %*% y)
\end{verbatim}

\({{x}\times{y}}\)

\begin{verbatim}
catmath(x %.% y)
\end{verbatim}

\({{x}\cdot{y}}\)

\begin{verbatim}
catmath(X %x% Y)
\end{verbatim}

\({{X}\otimes{Y}}\)

\begin{verbatim}
catmath(x/y)
\end{verbatim}

\({{x}/{y}}\)

\begin{verbatim}
catmath(x %/% y)
\end{verbatim}

\({\lfloor{{x}/{y}}\rfloor}\)

\hypertarget{subscripts-and-superscripts}{%
\subsection{Subscripts and Superscripts}\label{subscripts-and-superscripts}}

Secondly, \pkg{mathml} allows also for the display of subscripts, superscripts and their combination.

\begin{verbatim}
catmath(a["x"])
\end{verbatim}

\({{a}_\mathrm{x}}\)

\begin{verbatim}
catmath(a^x)
\end{verbatim}

\({{{a}}^{{x}}}\)

\begin{verbatim}
catmath(x["b"]^"a")
\end{verbatim}

\({{x}_\mathrm{b}^\mathrm{a}}\)

\hypertarget{fractions}{%
\subsection{Fractions}\label{fractions}}

As in (Murrell and Ihaka 2000) the \texttt{frac} and \texttt{over} functions aim to represent fractions. \texttt{choose} and \texttt{lchoose}, as in R~\pkg{base}, display the binomial coefficient.

\begin{verbatim}
catmath(frac(x, y))
\end{verbatim}

\(\frac{{x}}{{y}}\)

\begin{verbatim}
catmath(over(x, y))
\end{verbatim}

\(\frac{{x}}{{y}}\)

\begin{verbatim}
catmath(choose(n, k))
\end{verbatim}

\(\binom{{n}}{{k}}\)

\begin{verbatim}
catmath(lchoose(n, k))
\end{verbatim}

\({\log\binom{{n}}{{k}}}\)

\hypertarget{radicals}{%
\subsection{Radicals}\label{radicals}}

\begin{verbatim}
catmath(sqrt(x))
\end{verbatim}

\(\sqrt{{x}}\)

\hypertarget{relations}{%
\subsection{Relations}\label{relations}}

Among the possible relational operators, following (Murrell and Ihaka 2000), we included:

\begin{verbatim}
catmath(x==y)
\end{verbatim}

\({{x}={y}}\)

\begin{verbatim}
catmath(x < y)
\end{verbatim}

\({{x}<{y}}\)

\begin{verbatim}
catmath(x <= y)
\end{verbatim}

\({{x}\le{y}}\)

\begin{verbatim}
catmath(x >= y)
\end{verbatim}

\({{x}\ge{y}}\)

\begin{verbatim}
catmath(!x)
\end{verbatim}

\({\lnot{x}}\)

\begin{verbatim}
catmath(x != y)
\end{verbatim}

\({{x}\ne{y}}\)

\begin{verbatim}
catmath(X ~ Y)
\end{verbatim}

\({{X}\sim{Y}}\)

\begin{verbatim}
catmath(x %~~% y)
\end{verbatim}

\({{x}\approx{y}}\)

\begin{verbatim}
catmath(x %==% y)
\end{verbatim}

\({{x}\equiv{y}}\)

\begin{verbatim}
catmath(x %=~% y)
\end{verbatim}

\({{x}\cong{y}}\)

\begin{verbatim}
catmath(x %prop% y)
\end{verbatim}

\({{x}\propto{y}}\)

\hypertarget{set-relations}{%
\subsection{Set relations}\label{set-relations}}

Here is provided a series of useful set relations.

\emph{Still to be implemented}

\begin{verbatim}
catmath(a %in% A)
\end{verbatim}

\({{a}\in{A}}\)

\begin{verbatim}
catmath(intersect(A, B))
\end{verbatim}

\({{A}\cap{B}}\)

\begin{verbatim}
catmath(union(A, B))
\end{verbatim}

\({{A}\cup{B}}\)

\begin{verbatim}
catmath(is.null(intersect(A, B)))
\end{verbatim}

\({{{A}\cap{B}}=\emptyset}\)

\hypertarget{arrows}{%
\subsection{Arrows}\label{arrows}}

Following once again (Murrell and Ihaka 2000), we provide here a list of useful arrows

\begin{verbatim}
# x %<->% y
catmath(x %<->% y)
\end{verbatim}

\({{x}\leftrightarrow{y}}\)

\begin{verbatim}
# x %->% y
catmath(x %->% y)
\end{verbatim}

\({{x}\rightarrow{y}}\)

\begin{verbatim}
# x %<-% y
catmath(x %<-% y)
\end{verbatim}

\({{x}\leftarrow{y}}\)

\begin{verbatim}
# x %up% y:
catmath(x %up% y)
\end{verbatim}

\({{x}\uparrow{y}}\)

\begin{verbatim}
# x %down% y:
catmath(x %down% y)
\end{verbatim}

\({{x}\downarrow{y}}\)

\begin{verbatim}
# x %<=>% y: solved it using iff
catmath(x %<=>% y)
\end{verbatim}

\({{x}\iff{y}}\)

\begin{verbatim}
# x %=>% y: solved using rArr
catmath(x %=>% y)
\end{verbatim}

\({{x}\Rightarrow{y}}\)

\begin{verbatim}
# x %<=% y: solved using lArr
catmath(x %<=% y)
\end{verbatim}

\({{x}\Leftarrow{y}}\)

\begin{verbatim}
# x %dblup% y:
catmath(x %dblup% y)
\end{verbatim}

\({{x}\Uparrow{y}}\)

\begin{verbatim}
# x %dbldown% y:
catmath(x %dbldown% y)
\end{verbatim}

\({{x}\Downarrow{y}}\)

\hypertarget{accents}{%
\subsection{Accents}\label{accents}}

\begin{verbatim}
catmath(hat(x))
\end{verbatim}

\(\hat{{x}}\)

\begin{verbatim}
catmath(hat(xy))
\end{verbatim}

\(\hat{{xy}}\)

\begin{verbatim}
catmath(mean(x))
\end{verbatim}

\(\overline{{x}}\)

\begin{verbatim}
catmath(mean(xy))
\end{verbatim}

\(\overline{{xy}}\)

\hypertarget{symbolic-names}{%
\subsection{Symbolic names}\label{symbolic-names}}

\begin{verbatim}
catmath(A-Omega)
\end{verbatim}

\({{A}-\Omega}\)

\begin{verbatim}
catmath(alpha-omega)
\end{verbatim}

\({\alpha-\omega}\)

\begin{verbatim}
catmath(pi-Pi)
\end{verbatim}

\({\pi-\Pi}\)

\begin{verbatim}
catmath(Inf)
\end{verbatim}

\(\infty\)

\hypertarget{operators}{%
\subsection{Operators}\label{operators}}

A list of possible operators is available here.

\begin{verbatim}
catmath(sum(x[i], i==1L, n))
\end{verbatim}

\({{\sum}\left({{{x}_{i}}{,{{i}={1}}{,{n}}}}\right)}\)

\begin{verbatim}
# fixme: braces not needed when right to *
catmath(a * sum(b))
\end{verbatim}

\({{a}\cdot{{\sum}{b}}}\)

\begin{verbatim}
# Multiplication (capital Pi) is missing
catmath(a * prod(b))
\end{verbatim}

\({{a}\cdot{{\prod}{b}}}\)

\begin{verbatim}
catmath(integrate(sin, 0L, 2L*pi))
\end{verbatim}

\(\int_{{0}}^{{{2}{}\pi}}{{\sin{x}}}\,{d{x}}\)

\begin{verbatim}
catmath(A & B)
\end{verbatim}

\({{A}\land{B}}\)

\begin{verbatim}
catmath(A | B)
\end{verbatim}

\({{A}\lor{B}}\)

\begin{verbatim}
catmath(!A)
\end{verbatim}

\({\lnot{A}}\)

\begin{verbatim}
catmath(xor(A, B))
\end{verbatim}

\({{A}\veebar{B}}\)

\begin{verbatim}
catmath(exp(2L*pi*i))
\end{verbatim}

\({\exp\left({{{2}{}\pi}\cdot{i}}\right)}\)

\begin{verbatim}
catmath(expm1(2L*pi*i))
\end{verbatim}

\({{\exp\left({{{2}{}\pi}\cdot{i}}\right)}-{1}}\)

\begin{verbatim}
catmath(log(x))
\end{verbatim}

\({\log{x}}\)

\begin{verbatim}
catmath(log10(x))
\end{verbatim}

\({{\log_{10}}{x}}\)

\begin{verbatim}
catmath(log2(x))
\end{verbatim}

\({{\log_{2}}{x}}\)

\begin{verbatim}
catmath(logb(x, e))
\end{verbatim}

\({{\log_{e}}{x}}\)

\begin{verbatim}
catmath(log1p(x))
\end{verbatim}

\({{1}+{\log{x}}}\)

\begin{verbatim}
catmath(ceiling(pi))
\end{verbatim}

\({\lceil\pi\rceil}\)

\begin{verbatim}
catmath(floor(pi))
\end{verbatim}

\({\lfloor\pi\rfloor}\)

\begin{verbatim}
catmath(sin(pi/2L))
\end{verbatim}

\({\sin\left({\pi/{2}}\right)}\)

\begin{verbatim}
catmath(cos(pi/2L))
\end{verbatim}

\({\cos\left({\pi/{2}}\right)}\)

\begin{verbatim}
catmath(tan(pi/2L))
\end{verbatim}

\({\tan\left({\pi/{2}}\right)}\)

\hypertarget{grouping}{%
\subsection{Grouping}\label{grouping}}

At first glance, grouping expressions may seem trivial enough. However, when you want to deal with, for instance, exponentiation or multiplication, things can get more complicated. Let us consider a trivial example. If we want to calculate and evaluate the expression \texttt{a\ *\ (b\ +\ c)}, we find that R~automatically gives precedence to the addition even if we do not specify it in the text, as in the following.

\begin{verbatim}
first <- quote(a)
second <- quote(b + c)
mathout(call("*", first, second))
\end{verbatim}

\({{a}\cdot\left({{b}+{c}}\right)}\)

\begin{verbatim}
# precedence
quote(a * (b + c))[[3]][[1]]
\end{verbatim}

\texttt{(}

With exponentiation the situation can be less trivial. If we consider \texttt{x} to the power of \texttt{y\ +\ z}, following R~notation we should add a parenthesis around the two terms. Otherwise R~would consider only \texttt{y} as power of \texttt{x}.

\begin{verbatim}
catmath(x^y + z)
\end{verbatim}

\({{{{x}}^{{y}}}+{z}}\)

\begin{verbatim}
# mathout(call("+", call("^", as.symbol("x"), as.symbol("y")), as.symbol("z")))

catmath(x^(y + z))
\end{verbatim}

\({{{x}}^{\left({{y}+{z}}\right)}}\)

Unfortunately, R~automatically put \texttt{y\ +\ z} in parentheses even if, from a mathematical point of view, the brackets are not needed. To solve this issue two solutions are possible, the first one is cumbersome since it requires many specifications. The second, that can be considered a shortcut, uses a syntax similar to LateX and puts the power in curly brackets. In both cases the output produced is consistent with the mathematical notation.

\begin{verbatim}
# without parenthesis
mathout(canonical(call("^", as.symbol("x"), call("+", as.symbol("y"), as.symbol("z")))))
\end{verbatim}

\({{{x}}^{{{y}+{z}}}}\)

\begin{verbatim}
# shortcut
catmath(x^{y + z})
\end{verbatim}

\({{{x}}^{{{y}+{z}}}}\)

\hypertarget{absolute-value}{%
\subsection{Absolute value}\label{absolute-value}}

Is it also possible to calculate and represent the absolute value, as:

\begin{verbatim}
catmath(abs(x))
\end{verbatim}

\(\left|{{x}}\right|\)

\hypertarget{matrix-and-vectors}{%
\subsection{Matrix and Vectors}\label{matrix-and-vectors}}

Since also Matrices and Vectors are important elements in R, we decided to implement them and render them graphically in the following ways.

\begin{verbatim}
vec <- 1:3
mathout(canonical(vec))
\end{verbatim}

\(\left({{1}{\,{2}{\,{3}}}}\right)\)

\begin{verbatim}
mathout(vec)
\end{verbatim}

\(\left({{1}{\,{2}{\,{3}}}}\right)\)

\begin{verbatim}
mat <- matrix(data = c(2L, 3L, 4L, 5L), nrow = 2, ncol = 2)
mathout(canonical(mat))
\end{verbatim}

\(\left(\begin{array}{cc}{2} & {4}\\ {3} & {5}\\ \end{array}\right)\)

\hypertarget{abbreviations}{%
\subsection{Abbreviations}\label{abbreviations}}

\pkg{mathml} allows also for the use of abbreviations in formulas. Let us consider here the t-statistic for independent samples with equal variance assumed.
The procedure consists of three steps. The first one is to define the hooks to nicely print the variables. Second, we write the t-statistic specifying in the formula how to calculate the pooled variance with the function \texttt{denote(abbr,\ expr,\ info)}. Finally, since \pkg{mathml} also allows computation, we can directly compute the value of the t statistic with \texttt{eval()}.

\begin{verbatim}
hook(quote(x_1), quote(mean(x["1"])))
hook(quote(x_2), quote(mean(x["2"])))
hook(quote(n_1), quote(n["1"]))
hook(quote(n_2), quote(n["2"]))
hook(quote(s_1), quote(s["1"]))
hook(quote(s_2), quote(s["2"]))
hook(quote(s_p), quote(s["pool"]))


t <- quote(dfrac(x_1 - x_2, sqrt(denote(s_p^2L, frac((n_1 - 1L)*s_1^2L + (n_2 - 1L)*s_2^2L, n_1+n_2-2L), "the pooled variance.") * (dfrac(1L, n_1)+dfrac(1L,n_2)))))
  
mathout(t)
\end{verbatim}

\(\displaystyle{\frac{{\overline{{{x}_\mathrm{1}}}-\overline{{{x}_\mathrm{2}}}}}{\sqrt{{{{s}_\mathrm{pool}^{2}}\cdot\left({\displaystyle{\frac{{1}}{{{n}_\mathrm{1}}}}+\displaystyle{\frac{{1}}{{{n}_\mathrm{2}}}}}\right)}}}}\), with \({{{s}_\mathrm{pool}^{2}}=\frac{{{\left({{{n}_\mathrm{1}}-{1}}\right)\cdot{{s}_\mathrm{1}^{2}}}+{\left({{{n}_\mathrm{2}}-{1}}\right)\cdot{{s}_\mathrm{2}^{2}}}}}{{{{{n}_\mathrm{1}}+{{n}_\mathrm{2}}}-{2}}}}\) denoting the pooled variance.

\begin{verbatim}
# An example

x_1 = 20.5
x_2 = 35.7
n_1 = 150
n_2 = 160
s_1 = 3.4
s_2 = 4.2

eval(t)
\end{verbatim}

{[}1{]} -34.88421

\hypertarget{a-case-study}{%
\section{A case study}\label{a-case-study}}

For a more clear representation of what the \pkg{mathml} package is supposed to do, we provide here a case study, based on the work by Schwarz (1994), in which the features of \pkg{mathml} are implemented.

The reader may recognize that Schwarz' (1994) study can be traced back to the strand of decision-making models, where decision-making is assumed to be a process of
noisy accumulation of information over time (e.g., Ratcliff et al. 2016). The aim of
Schwarz' (1994) study is to present a new explanation of redundancy gains when
observers make speeded responses to stimuli of different sources, and the same
information is presented on two channels. Schwarz (1994) describes a model that assumes
the superposition of channel-specific diffusion processes that eventually reach
an absorbing barrier to elicit the response. For a detailed description the
reader may refer to the original article.

\hypertarget{the-model}{%
\subsubsection{The model}\label{the-model}}

Schwarz' (1994) model refers to two stimuli A and B, presented either
alone or in combination (redundant stimuli), with the redundant stimuli being
presented either simultaneously or with onset asynchrony \(\tau\). The channel
activation is described as a two-dimensional Wiener process with
drifts \(\mu_\mathrm A\), \(\mu_\mathrm B\),
variances \(\sigma^2_\mathrm A\), \(\sigma^2_\mathrm B\),
correlation \(\rho_\mathrm{AB}\) and initial
conditions \(X_i(t=0)=0, i=\mathrm{A, B}\). The response is elicited when the
process reaches the absorbing barrier \(c > 0\) for the first time. In combined
stimuli (``redundant'' stimuli), the overall diffusion process
is \(X_\mathrm{AB}(t) = X_\mathrm A(t) + X_\mathrm B(t)\) , which is again a
Wiener process with drift \(\mu_\mathrm A + \mu_\mathrm B\) and
variance \(\sigma^2_\mathrm A + \sigma^2_\mathrm B  + 2\rho_\mathrm{AB}\sigma_\mathrm A\sigma_\mathrm B\).

In single-target trials, the first passages at \(c\) are expected at
\(E\left[D_i\right] = \frac{c}{\mu_i}, i = \mathrm{A, B}\), whereas in synchronous
redundant-target trials, we have
\(E[D_\mathrm{AB}]= \frac{c}{\mu_\mathrm A + \mu_\mathrm B}\).

For asynchronous stimuli, Schwarz (1994) derived the expected
first-passage time \(E[D_{\mathrm A(\tau)\mathrm B}]\) as a function of the
stimulus onset asyncrony \(\tau > 0\) (Eq.~10),

\begin{verbatim}
f <- function(tau, c, mu_A, sigma_A, mu_B, sigma_B)
{ dfrac(c, mu_A) + (dfrac(1L, mu_A) - dfrac(1L, mu_A + mu_B)) *
    ((mu_A*tau - c) * pnorm(dfrac(c - mu_A*tau, sqrt(sigma_A^2L*tau)))
      - (mu_A*tau + c) * exp(dfrac(2L*mu_A*c, sigma_A^2L))
        * pnorm(dfrac(-c - mu_A*tau, sqrt(sigma_A^2L*tau))))
}

mathout(f)
\end{verbatim}

\({{\lambda\left({\tau{\,{c}{\,{\mu_\mathrm{A}}{\,{\sigma_\mathrm{A}}{\,{\mu_\mathrm{B}}{\,{\sigma_\mathrm{B}}}}}}}}\right)}={\displaystyle{\frac{{c}}{{\mu_\mathrm{A}}}}+{\left({\displaystyle{\frac{{1}}{{\mu_\mathrm{A}}}}-\displaystyle{\frac{{1}}{{{\mu_\mathrm{A}}+{\mu_\mathrm{B}}}}}}\right)\cdot\left[{{\left({{{\mu_\mathrm{A}}{}\tau}-{c}}\right)\cdot{\Phi\left(\displaystyle{\frac{{{c}-{{\mu_\mathrm{A}}{}\tau}}}{\sqrt{{{\sigma_\mathrm{A}^{2}}{}\tau}}}}\right)}}-{{\left({{{\mu_\mathrm{A}}{}\tau}+{c}}\right)\cdot{\exp\left(\displaystyle{\frac{{{{2}{}{\mu_\mathrm{A}}}\cdot{c}}}{{\sigma_\mathrm{A}^{2}}}}\right)}}\cdot{\Phi\left(\displaystyle{\frac{{{-{c}}-{{\mu_\mathrm{A}}{}\tau}}}{\sqrt{{{\sigma_\mathrm{A}^{2}}{}\tau}}}}\right)}}}\right]}}}\)

The observable response time is assumed to be the sum of \(D\), the time
employed to reach the threshold for the decision, and \(M\), denoting the of the
other processes.

\(E[T]= E[D + M] = E[D] + E[M] = E[D] + \mu_M\)

\hypertarget{methods}{%
\subsubsection{Methods}\label{methods}}

Schwarz (1994) applied the model to Miller's (1986) data from
a redundant signals task with 13 onset
asynchronies \(0, \pm33, \pm67, \pm100, \pm133, \pm167, \pm\infty\) ms,
where 0 refers to synchronous AB, \(\infty\) refers to the single-target
presentation, and negative \(\tau\) denote those conditions in which B is
presented before A. Each condition was replicated 400 times. The 13 mean RTs and
standard deviations are given in Table 2 below.

Then, from Schwarz' (1994) Equations {[}2{]} {[}3{]} and {[}10{]}, we calculated the expected first time passage for the respective \(\tau\) and the parameters \(\mu_ \mathrm A = 0.53, \mu_ \mathrm B = 1.32, \sigma_ \mathrm A = 4.43, \sigma_ \mathrm B = 18.3, c = 100, \mu_\mathrm M = 161\)

\({{\lambda\left({\tau{\,{c}{\,{\mu_\mathrm{A}}{\,{\sigma_\mathrm{A}}{\,{\mu_\mathrm{B}}{\,{\sigma_\mathrm{B}}}}}}}}\right)}={{rbind}\left({\displaystyle{\frac{{c}}{{\mu_\mathrm{A}}}},\ \mathrm{if}\ {\tau=\infty}{\,\displaystyle{\frac{{c}}{{\mu_\mathrm{B}}}},\ \mathrm{if}\ {\tau={-\infty}}{\,{{f}\left({\tau{,{c}{,{\mu_\mathrm{A}}{,{\sigma_\mathrm{A}}{,{\mu_\mathrm{B}}{,{\sigma_\mathrm{B}}}}}}}}\right)},\ \mathrm{if}\ {\tau>{0}}{\,\displaystyle{\frac{{c}}{{{\mu_\mathrm{A}}+{\mu_\mathrm{B}}}}},\ \mathrm{if}\ {\tau={0}}{\,{{f}\left({{-\tau}{,{c}{,{\mu_\mathrm{B}}{,{\sigma_\mathrm{B}}{,{\mu_\mathrm{A}}{,{\sigma_\mathrm{A}}}}}}}}\right)},\ \mathrm{if}\ {\tau<{0}}}}}}}\right)}}\)

For instance, we can see that with \(\tau = -167\) the expected first passage time is:

\begin{verbatim}
#> [1] 70.31943
\end{verbatim}

To which we have to add \(\mu_M = 161\) (which represents the amount of time that the movement of providing the answer takes) and we obtain:

\begin{verbatim}
#> [1] 231.3194
\end{verbatim}

Similarly, we obtain the first-time passage for every \(\tau\):

\({{\lambda\left({\tau{\,{c}{\,{\mu_\mathrm{A}}{\,{\sigma_\mathrm{A}}{\,{\mu_\mathrm{B}}{\,{\sigma_\mathrm{B}}{\,{\mu_\mathrm{M}}}}}}}}}\right)}={{{G}\left({\tau{,{c}{,{\mu_\mathrm{A}}{,{\sigma_\mathrm{A}}{,{\mu_\mathrm{B}}{,{\sigma_\mathrm{B}}}}}}}}\right)}+{\mu_\mathrm{M}}}}\)

\begin{verbatim}
#>  [1] 236.7576 231.3194 230.0571 228.4017 226.0523 222.2336 215.0541 238.5977
#>  [9] 262.3817 282.9833 299.7299 312.9791 349.6792
\end{verbatim}

\hypertarget{model-fitting-and-parameters-estimation}{%
\subsubsection{Model fitting and Parameters Estimation}\label{model-fitting-and-parameters-estimation}}

Then we proceeded with the model fitting, using the data provided by Miller (1986) study in Schwarz (1994). First, we calculated the predicted means RT as \(E[RT]=E[T]+\mu_M\).

We briefly remind that in diffusion models there is across-trial variability, and the drift rates are assumed to be normally distributed (Ratcliff and McKoon 2008) with at the first passage of \(c\) \(X(t) \sim N(\mu t , \sigma^2 t)\). Where \(T\) is expressed as \(T= \arg \min_t X(t)\geq c\) with \(T \sim IG (c, \mu, \sigma^2)\) with mean \(E(T)=\displaystyle \frac{c}{\mu}\) and variance \(Var(T)=\displaystyle \frac{c\sigma^2}{\mu^3}\). Furthermore, for the Central Limit Theorem \(\bar{T} = \displaystyle \frac{\Sigma_iT_i}{N} \dot\sim N (\displaystyle \frac{c}{\mu} , \displaystyle \frac{c\sigma^2}{\mu^3})\)

For these reasons, in order to obtain the Goodness of Fit measure we proceeded with a z-standardisation.

\({{\lambda\left({\overline{{X}}{\,{s}{\,{N}{\,\tau{\,{c}{\,{\mu_\mathrm{A}}{\,{\sigma_\mathrm{A}}{\,{\mu_\mathrm{B}}{\,{\sigma_\mathrm{B}}{\,{\mu_\mathrm{M}}}}}}}}}}}}\right)}={{rbind}\left({{{E}={{h}\left({\tau{,{c}{,{\mu_\mathrm{A}}{,{\sigma_\mathrm{A}}{,{\mu_\mathrm{B}}{,{\sigma_\mathrm{B}}{,{\mu_\mathrm{M}}}}}}}}}\right)}}{\,\displaystyle{\frac{{\overline{{X}}-{E}}}{{{s}/\sqrt{{N}}}}}}}\right)}}\)

\begin{verbatim}
#>  [1] -2.05627706  0.92433511 -0.02852697 -0.70084870  1.21730061 -0.88115730
#>  [7]  1.38996139 -0.42696106  0.47564623 -3.98888722 -1.08120914  1.77700915
#> [13] -0.36505332
\end{verbatim}

Then, we calculated the Goodness of Fit as follows:

\(X^2=\Sigma_\tau z^2_\tau \sim\chi^2(13-5\  dgf)\).

\({{\lambda\left({{par}{\,\tau{\,\overline{{X}}{\,{s}{\,{N}}}}}}\right)}={{rbind}\left({{{{z}_\tau}={{zf}\left({\overline{{X}}{,{s}{,{N}{,\tau{,{{c}={100}}{,{{\mu_\mathrm{A}}={{par}_\mathrm{mu_A}}}{,{{\sigma_\mathrm{A}}={{par}_\mathrm{sigma_A}}}{,{{\mu_\mathrm{B}}={{par}_\mathrm{mu_B}}}{,{{\sigma_\mathrm{B}}={{par}_\mathrm{sigma_B}}}{,{{\mu_\mathrm{M}}={{par}_\mathrm{mu_M}}}}}}}}}}}}}\right)}}{\,{{\sum}{{z}_\tau^{2}}}}}\right)}}\)

{[}1{]} 30.54472
{[}1{]} 0.0001692742

\({{\lambda\left({\tau{\,\overline{{X}}{\,{s}{\,{N}}}}}\right)}={{rbind}\left({{{start}={{c}\left({{{\mu_\mathrm{A}}={0.30}}{,{{\sigma_\mathrm{A}}={2.00}}{,{{\mu_\mathrm{B}}={1.00}}{,{{\sigma_\mathrm{B}}={5.00}}{,{{\mu_\mathrm{M}}={200.00}}}}}}}\right)}}{\,{{optim}\left({{start}{,{{fn}={gof}}{,{\tau=\tau}{,{\overline{{X}}=\overline{{X}}}{,{{s}={s}}{,{{N}={N}}{,{{hessian}={true}}{,{{control}={{list}\left({{fnscale}={1.00}}\right)}}}}}}}}}}\right)}}}\right)}}\)

\hypertarget{results}{%
\subsubsection{Results}\label{results}}

The calculated Goodness of Fit value is \(X^2= 30.54\), \(p= 0.0002\). Additionally, we proceeded with the parameters' estimation with the Least Squares Method.

The values of the estimated parameters reported in the table below are consistent with those reported by Schwarz (1994).

\begin{longtable}[]{@{}ccc@{}}
\caption{Table 1: Estimated Model's Parameters}\tabularnewline
\toprule()
Parameters & Estimate & 95\% Confidence Interval \\
\midrule()
\endfirsthead
\toprule()
Parameters & Estimate & 95\% Confidence Interval \\
\midrule()
\endhead
\(\mu_ \mathrm A\) & 0.53 & 0.51, 0.56 \\
\(\sigma_ \mathrm A\) & 4.4 & 3.8, 5.1 \\
\(\mu_ \mathrm B\) & 1.32 & 1.2, 1.4 \\
\(\sigma_ \mathrm B\) & 18.3 & 11.6, 24.9 \\
\(\mu_ \mathrm M\) & 161 & 157, 165 \\
\bottomrule()
\end{longtable}

Furthermore, we can observe from the values reported in the Table below that, with few exceptions (e.i. \(\tau= 100\)) Miller's (1986) observed values are quite similar to the one predicted by Schwarz' (1994) model. Showing that, despite the calculated Goodness of Fit measure, the model proposed by Schwarz (1994) sufficiently fit the data.

\begin{longtable}[]{@{}cccc@{}}
\caption{Table 2: Predicted Means RT and Observed Means RT and SDs from Miller's (1986) study in Schwarz (1994)}\tabularnewline
\toprule()
SOA & Predicted Mean RT & Observed Mean RT & Observed SD \\
\midrule()
\endfirsthead
\toprule()
SOA & Predicted Mean RT & Observed Mean RT & Observed SD \\
\midrule()
\endhead
\(-\infty\) & 237 & 231 & 56 \\
\(-167\) & 231 & 234 & 58 \\
\(-133\) & 230 & 230 & 40 \\
\(-100\) & 228 & 227 & 40 \\
\(-67\) & 226 & 228 & 32 \\
\(-33\) & 222 & 221 & 28 \\
\(0\) & 215 & 217 & 28 \\
\(33\) & 239 & 238 & 28 \\
\(67\) & 262 & 263 & 26 \\
\(100\) & 283 & 277 & 30 \\
\(133\) & 300 & 298 & 32 \\
\(167\) & 313 & 316 & 34 \\
\(\infty\) & 350 & 348 & 92 \\
\bottomrule()
\end{longtable}

\emph{Note}. Parameters: \(\mu_ \mathrm A = 0.53, \mu_ \mathrm B = 1.32, \sigma_ \mathrm A = 4.4, \sigma_ \mathrm B = 18.3, c = 100, \mu_\mathrm M = 161\)

\hypertarget{mistakes}{%
\subsection{Mistakes}\label{mistakes}}

The case study presented above displays several possible ways of how \pkg{mathml} can be a useful tool in data representation and calculation. Furthermore, the careful reader might have also noticed that \pkg{mathml} allows also for a more smoothly detection of possible mistakes in writing.

An interesting use case of the package is in this sense the readability of self-written
functions in R code. R code is notoriously hard to read, as are most programming
languages (Green 1977). The poor legibility of the language is one of the main
sources of mistakes. For illustration, we consider Equation 10 in
Schwarz (1994), namely the same equation reported above. The first version has a wrong parenthesis, which is barely visible in the R code.

\begin{verbatim}
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"]) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))))
}

attributes(f)$name = quote(f)
mathout(f)
\end{verbatim}

\({{{f}\left(\tau\right)}={\displaystyle{\frac{{c}}{{\mu_\mathrm{A}}}}+\left\{{\displaystyle{\frac{{1}}{{\mu_\mathrm{A}}}}-{\displaystyle{\frac{{1}}{{{\mu_\mathrm{A}}+{\mu_\mathrm{B}}}}}\cdot\left[{{\left({{{\mu_\mathrm{A}}{}\tau}-{c}}\right)\cdot{\Phi\left(\displaystyle{\frac{{{c}-{{\mu_\mathrm{A}}{}\tau}}}{\sqrt{{{\sigma_\mathrm{A}^{2}}{}\tau}}}}\right)}}-{{\left({{{\mu_\mathrm{A}}{}\tau}+{c}}\right)\cdot{\exp\left(\displaystyle{\frac{{{{2}{}{\mu_\mathrm{A}}}\cdot\tau}}{{\sigma_\mathrm{A}^{2}}}}\right)}}\cdot{\Phi\left(\displaystyle{\frac{{{-{c}}-{{\mu_\mathrm{A}}{}\tau}}}{\sqrt{{{\sigma_\mathrm{A}^{2}}{}\tau}}}}\right)}}}\right]}}\right\}}}\)

But, if the function is rendered in MathML, the wrong parenthesis appears as a curly
brace, and we immediately see the mistake. The correct version is shown below
for comparison.

\begin{verbatim}
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"])) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau))))
}

attributes(f)$name = quote(f)
mathout(f)
\end{verbatim}

\({{{f}\left(\tau\right)}={\displaystyle{\frac{{c}}{{\mu_\mathrm{A}}}}+{\left({\displaystyle{\frac{{1}}{{\mu_\mathrm{A}}}}-\displaystyle{\frac{{1}}{{{\mu_\mathrm{A}}+{\mu_\mathrm{B}}}}}}\right)\cdot\left[{{\left({{{\mu_\mathrm{A}}{}\tau}-{c}}\right)\cdot{\Phi\left(\displaystyle{\frac{{{c}-{{\mu_\mathrm{A}}{}\tau}}}{\sqrt{{{\sigma_\mathrm{A}^{2}}{}\tau}}}}\right)}}-{{\left({{{\mu_\mathrm{A}}{}\tau}+{c}}\right)\cdot{\exp\left(\displaystyle{\frac{{{{2}{}{\mu_\mathrm{A}}}\cdot\tau}}{{\sigma_\mathrm{A}^{2}}}}\right)}}\cdot{\Phi\left(\displaystyle{\frac{{{-{c}}-{{\mu_\mathrm{A}}{}\tau}}}{\sqrt{{{\sigma_\mathrm{A}^{2}}{}\tau}}}}\right)}}}\right]}}}\)

This example may seem trivial. However, as the reader well knows, a missed parenthesis is often the cause of untraceable errors and contradictory results. Thus, rendering the expression in MathMl improves the readability of the text, allowing better identification of the sources of possible errors.

\hypertarget{errors}{%
\subsection{Errors}\label{errors}}

An additional feature that this package offers is related to its application in educational scenarios. The functions here reported are intended to identify and highlight possible errors that students make, as well as provide the correct answer for the task.

In this first example the function highlights that the student forgot to add the left-hand side of the expression and it does that by striking the missing part. In this case the letter A and the operator \texttt{+}.
Similarly the function \texttt{omit\_right} does the same for the omissions in the right-hand side of the expression. Finally the function \texttt{omit()} can be used, for instance, to highlight the omission in the elements of a list.

\begin{verbatim}
t <- quote(omit_left(a + b))
mathout(t)
\end{verbatim}

\({{{cancel}\left({{a}{\,+}}\right)}{\,{b}}}\)

\begin{verbatim}
t <- quote(omit_right(a + b))
mathout(t)
\end{verbatim}

\({{a}{\,{{cancel}\left({+{\,{b}}}\right)}}}\)

\begin{verbatim}
t <- list(quote(a), quote(b), quote(omit(c)))
mathout(t)
\end{verbatim}

\({{a}{\,{b}{\,{{cancel}\left({c}\right)}}}}\)

The functions \texttt{add\_left()}, \texttt{add\_right()}, \texttt{add()} reported below follow the same way of reasoning, but they account for the mistakes made in adding incorrect elements in the expression. They highlight the redundant element placing it in a box.

\begin{verbatim}
t <- quote(add_left(a + b))
mathout(t)
\end{verbatim}

\({{{box}\left({{a}{\,+}}\right)}{\,{b}}}\)

\begin{verbatim}
t <- quote(add_right(a + b))
mathout(t)
\end{verbatim}

\({{a}{\,{{box}\left({+{\,{b}}}\right)}}}\)

\begin{verbatim}
t <- list(quote(a), quote(b), quote(add(c)), quote(d))
mathout(t)
\end{verbatim}

\({{a}{\,{b}{\,{{box}\left({c}\right)}{\,{d}}}}}\)

Finally the function \texttt{instead(\ ,\ )} place a curly bracket under the incorrect element and provides its correct version under the curly bracket. In order to provide the correction with this function one must fill it with its wrong and correct terms in this order: \texttt{instead(wrong,\ correct)}. An example of its use its provided below.

\begin{verbatim}
t <- quote(instead(a, b) + c)
mathout(t)
\end{verbatim}

\({{{underbrace}\left({{a}{,{\mathrm{instead of}{\,{b}}}}}\right)}+{c}}\)

It is also possible to use flags for context-dependent rendering. The highlight flag is the default one. It shows where the error is and what is its solution. The ignore flag allows the program to ignore the fact that there is an error and print the expression as if it were correct. Finally, the third flag, fix, tells you what is the term that you are supposed to fix without giving the solution. Below the code with its comment is provided.

\begin{verbatim}
# It highlights what has been omitted
t <- quote(omit_left(a + b))
mathout(t, flags=quote(error(highlight))) # default
\end{verbatim}

\({{{cancel}\left({{a}{\,+}}\right)}{\,{b}}}\)

\begin{verbatim}
# It prints the correct version
mathout(t, flags=quote(error(ignore)))
\end{verbatim}

\({{a}+{b}}\)

\begin{verbatim}
# It prints the correct version
mathout(t, flags=quote(error(asis)))
\end{verbatim}

\({b}\)

\begin{verbatim}
# It highlights the correct version by framing it
mathout(t, flags=quote(error(fix)))
\end{verbatim}

\({{{box}\left({{a}{\,+}}\right)}{\,{b}}}\)

\begin{verbatim}
# It frames the redundant term
t <- quote(add_right(a + b))
mathout(t, flags=quote(error(highlight))) # default
\end{verbatim}

\({{a}{\,{{box}\left({+{\,{b}}}\right)}}}\)

\begin{verbatim}
# It prints the correct expression without the redundant term
mathout(t, flags=quote(error(ignore)))
\end{verbatim}

\({a}\)

\begin{verbatim}
# It strikes the redundant term 
mathout(t, flags=quote(error(fix)))
\end{verbatim}

\({{a}{\,{{cancel}\left({+{\,{b}}}\right)}}}\)

\begin{verbatim}
# It highlights that a is wrong and b is correct
t <- quote(instead(a, b) + c)
mathout(t, flags=quote(error(highlight))) # default
\end{verbatim}

\({{{underbrace}\left({{a}{,{\mathrm{instead of}{\,{b}}}}}\right)}+{c}}\)

\begin{verbatim}
# It provides the correct solution
mathout(t, flags=quote(error(ignore)))
\end{verbatim}

\({{b}+{c}}\)

\begin{verbatim}
# It provides the correct solution framing the correct term
mathout(t, flags=quote(error(fix)))
\end{verbatim}

\({{{box}\left({b}\right)}+{c}}\)

\hypertarget{conclusions}{%
\section{Conclusions}\label{conclusions}}

This package expands the possibilities of R~by allowing calculations and graphical rendition at the same time. This makes it easier for the user to notice writing errors and correct them smoothly. Building on current features of R~and existing packages for displaying formulas in R~(e.g.~Murrell and Ihaka (2000), Allaire et al. (2018)), the \pkg{mathml} package bridges the gap between computational needs, presentation of results, and their reproducibility. To do so, it uses the Prolog's grammar rules and translates the R~expressions to MathML. Then, two possible solutions for typesetting are available to export R~Markdown documents in different formats or ShinyApp webpages: MathML and MathJax.

The article and Appendix show examples of how the package can be used and what operations are currently possible. Additionally, \pkg{mathml} allows for user's custom hooks to provide a better definition of the needed functions.

In its current version \pkg{mathml} has some limitations. For example, it is still not possible to use the functions of \pkg{mathml} for writing intratextual formulas, while it is still more convenient to adopt the usual LateX notation. However, we do not consider this to be a serious limitation, since the most productive use of \pkg{mathml} still comes from more complicated calculations. Nevertheless, in the future versions of this package we will address this issue, to broaden its spectrum of possible applications.

\pkg{mathml} is available for R~version (\ldots) and later, and can be easily installed using the usual \texttt{install.packages("mathml")}. The source code of the package is found at (\ldots) including installation instructions for Unix, Windows and macOS.

\hypertarget{acknowledgments}{%
\section{Acknowledgments}\label{acknowledgments}}

\hypertarget{references}{%
\section*{References}\label{references}}
\addcontentsline{toc}{section}{References}

\hypertarget{refs}{}
\begin{CSLReferences}{1}{0}
\leavevmode\vadjust pre{\hypertarget{ref-allaire2018}{}}%
Allaire, JJ, Rich Iannone, Alison Presmanes Hill, and Yihui Xie. 2018. {``Distill for r Markdown.''} \url{https://rstudio.github.io/distill}.

\leavevmode\vadjust pre{\hypertarget{ref-Chang2022}{}}%
Chang, Winston, Joe Cheng, JJ Allaire, Carson Sievert, Barret Schloerke, Yihui Xie, Jeff Allen, Jonathan McPherson, Alan Dipert, and Barbara Borges. 2022. \emph{Shiny: Web Application Framework for r}. \url{https://CRAN.R-project.org/package=shiny}.

\leavevmode\vadjust pre{\hypertarget{ref-green1977}{}}%
Green, T. R. G. 1977. {``Conditional Program Statements and Their Comprehensibility to Professional Programmers.''} \emph{Journal of Occupational Psychology} 50: 93--109.

\leavevmode\vadjust pre{\hypertarget{ref-miller1986}{}}%
Miller, Jeff. 1986. {``Timecourse of Coactivation in Bimodal Divided Attention.''} \emph{Perception \& {P}sychophysics} 40: 331--43.

\leavevmode\vadjust pre{\hypertarget{ref-murrell2000}{}}%
Murrell, Paul, and Ross Ihaka. 2000. {``An Approach to Providing Mathematical Annotation in Plots.''} \emph{Journal of Computational and Graphical Statistics} 9: 582--99. \url{https://www.jstor.con/stable/1390947}.

\leavevmode\vadjust pre{\hypertarget{ref-R}{}}%
R Core Team. 2021. \emph{R: A Language and Environment for Statistical Computing}. Vienna, Austria: R Foundation for Statistical Computing. \url{https://www.R-project.org/}.

\leavevmode\vadjust pre{\hypertarget{ref-ratcliff2008}{}}%
Ratcliff, Roger, and Gail McKoon. 2008. {``The Diffusion Decision Model: Theory and Data for Two-Choice Decision Task.''} \emph{Neural Computation} 20: 873--922.

\leavevmode\vadjust pre{\hypertarget{ref-ratcliff2016}{}}%
Ratcliff, Roger, Philip L. Smith, Scott D. Brown, and Gail McKoon. 2016. {``Diffusion Decision Model: Current Issues and History.''} \emph{Trends in Cognitive Sciences} 20: 260--81.

\leavevmode\vadjust pre{\hypertarget{ref-Sarkar2022}{}}%
Sarkar, Deepayan, and Kurt Hornik. 2022. \emph{Enhancements to {HTML} {D}ocumentation}. \url{https://blog.r-project.org/2022/04/08/enhancements-to-html-documentation/index.html}.

\leavevmode\vadjust pre{\hypertarget{ref-schwarz1994}{}}%
Schwarz, Wolf. 1994. {``Diffusion, Superposition, and the Redundant-Targets Effect.''} \emph{Journal of Mathematical Psychology} 38: 504--20.

\leavevmode\vadjust pre{\hypertarget{ref-Xie2020}{}}%
Xie, Y., C. Dervieux, and E. Riederer. 2020. \emph{R Markdown Cookbook}. Cambridge: Chapman; Hall/CRC.

\end{CSLReferences}

\bibliography{RJreferences.bib}

\address{%
Matthias Gondan\\
University of Innsbruck\\%
Department of Psychology\\ Innsbruck, Austria\\
%
\url{https://www.uibk.ac.at/psychologie/mitarbeiter/gondan-rochon/index.html.en}\\%
\textit{ORCiD: \href{https://orcid.org/0000-0001-9974-0057}{0000-0001-9974-0057}}\\%
\href{mailto:Matthias.Gondan-Rochon@uibk.ac.at}{\nolinkurl{Matthias.Gondan-Rochon@uibk.ac.at}}%
}

\address{%
Irene Alfarone\\
University of Innsbruck\\%
Department of Psychology\\ Innsbruck, Austria\\
%
\url{https://www.uibk.ac.at/psychologie/mitarbeiter/alfarone/index.html.en}\\%
\textit{ORCiD: \href{https://orcid.org/0000-0002-8409-8900}{0000-0002-8409-8900}}\\%
\href{mailto:Irene.Alfarone@uibk.ac.at}{\nolinkurl{Irene.Alfarone@uibk.ac.at}}%
}
