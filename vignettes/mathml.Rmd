---
title: "mathml: Translate R expressions to MathML"
author: "Matthias Gondan (Department of Psychology, University of Innsbruck, Austria)"
date: "2022-07-24"
bibliography: bibliography.bibtex
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mathml}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

````{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(rmarkdown.html_vignette.check_title=FALSE)
library(mathml)
````

  Matthias Gondan\
  Department of Psychology\
  University of Innsbruck\
  Innrain 9\
  A-6020 Innsbruck\
  Matthias.Gondan-Rochon@uibk.ac.at
  
# Abstract

123

## Keywords

HTML; MathML; R

# 1. mathml: Translate R expressions to MathML

The R extension of the markdown language [@Xie2020] enables reproducible
statistical reports with nice typesetting in HTML, Microsoft Word, and Latex.
However, so far, R expressions such as `pbinom(k, N, p)` are printed as-is; 
prettier mathematical expressions such as $P_\mathrm{Bi}(X \le k; N, p)$ require
Latex commands like `P_\mathrm{Bi}\left(X \le k; N, p\right)`. Except for
minimalistic examples, these commands are tedious to type in and hard to read in
the original code. Since recently [@R, version 4.2], manual pages include
support for mathematical expressions [@Sarkar2022], which already is a big
improvement. Rules for the translation of R's built-in language elements to
their mathematical representation are lacking.

In this R package, such rules are defined for the _automatic_ translation of R
expressions mathematical output. The translation is done by an embedded
Prolog interpreter that maps nested expressions recursively to MathML and
LaTeX/MathJax, respectively, for typesetting of R Markdown documents in
different formats or ShinyApp webpages. User-defined hooks enable to extend the
set of rules and/or replace specific R elements by special mathematical signs.

## Macros

The mathml package uses two classes of rules to translation of R expressions to
a mathematical representation, macros and target-specific rules. Macros make use
of the available elements of the R\ language, including extensions provided by
the package. In other words, macros translate R\ expressions to other
R\ expressions. For example, mathml defines a macro that translates the
R\ expression `dbinom(x, size, prob)`
to `fn(subscript(P, "Bi"), ';'(list(X <= x), list(size, prob)))`, that is, a
function with the name \(P_\mathrm{Bi}\), the argument \(X \le x\) and two
parameters size and prob.

With mathml, target-specific rules are then used to render these basic elements
in either MathML (`<mrow><msub><mi>P</mi><mtext>Bi</mtext></msub>...`) or
MathJax/Latex (`P_\mathrm{bi}\left(...\right)`).

## User-defined hooks

Mathematical expressions are typically rather concise, with a limited set of
identifiers for variables and functions (e.g., \(f(x)\)). In contrast, typical
R programs use informative names for variables and functions. As illustrated in
the example below, the one-to-one translation of these variable and function
names to MathML/MathJax often yields aesthetically unsatisfactory results.

````{r, results="asis"}
term <- quote(pbinom(successes, size, prob))
mathml(term)
````

The situation can be improved by user-defined hooks ("macros", in the
terminology of the previous section) that map individual elements to prettier
mathematical counterparts.

````{r, results="asis"}
hook(quote(successes), quote(k))
hook(quote(size), quote(N))
hook(quote(prob), quote(pi))

term <- quote(pbinom(successes, size, prob))
mathml(term)
````

The user should be careful not to define recursive hooks, e.g., something
like `hook(quote(X), quote(overline(X)))` results in an endless loop.

If the hooks apply to individual elements as in the example above, every
subsequent occurrence of `successes` will be translated to \(k\), which may not
be desired. More complex hooks allow to restrict such replacements to specific
terms, such as replacement of `s1` to \(k\) only if `s1` occurs as the first
argument of `pbinom`, as shown below.

````{r, results="asis"}
hook(call("pbinom", quote(s1), expression(Size), expression(Prob)), 
     call("pbinom", quote(k), expression(Size), expression(Prob)))

term <- quote(dbinom(s1, N, p))
mathml(term)
term <- quote(pbinom(s1, N, p))
mathml(term)
````

Note that the `s1` in `dbinom` is left untouched.

````{r, results="asis"}
hook(call("f", expression(Tau), expression(C), expression(Mu_A), expression(Sigma_A), expression(Mu_V), expression(Sigma_V)), 
     call("fn", call("paren", expression(Tau), expression(C), expression(Mu_A), expression(Sigma_A), expression(Mu_V), expression(Sigma_V))))
````

Note that the `s1` in `dbinom` is left untouched.

## Extending the package

Example: plus/minus

# Discussion

The result can then be used for calculations or it can be
rendered on a web page. A limited set of rules for translation from R to MathML
is found in `pl/mathml.pl` of the rolog package. The relevant code snippets are
shown in the listings below, along with their output.

```{r, results="asis"}
library(mathml)

term <- quote(pbinom(k, N, p))
# hook(quote(p), quote(pi))
mathml(term)

# Do some calculations with the same term
k = 10
N = 22
p = 0.4
eval(term)
```


```{r}
catmath <- function(term)
{
  s <- substitute(term)
  c <- canonical(s)
  mathml(c)
}

catmathjax <- function(term)
{
  s <- substitute(term)
  c <- canonical(s)
  mathjax(c)
}
```

## Mistakes

An interesting use case of the package is the readability of self-written
functions in R code. R code is notoriously hard to read, as are most programming
languages [@green1977]. The poor legibility of the language is one of the main
sources of mistakes. For illustration, consider Equation 10 in
Schwarz [@schwarz1994]. The first version has a wrong parenthesis, which is
barely visible in the R code.

````{r, results="asis"}
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"]) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))))
}

attributes(f)$name = quote(f)
mathml(f)
````

If the function is rendered in MathML, the wrong parenthesis appears as a curly
brace, and we immediately see the mistake. The correct version is shown below
for comparison.

````{r, results="asis"}
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"])) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau))))
}

attributes(f)$name = quote(f)
mathml(f)
````

## Mathematical Annotation in R  @murrell2000

### To do list:
* Aritmetic operators: \( \times \div \) 
* Juxtaposition: _paste_
* Spacing
* Comma separated list
* Ellipsis
* Radicals: \(\sqrt[3]2\)
* Relations: \(\equiv \simeq \approx \cong ...\)
* Set relations
* Arrows
* Accent
* Symbolic names
* Operators: \(\lim \min\)
* Grouping: \( (a, b]\)
* Phantoms

### Arithmetic Operators

```{r results="asis"}

catmath(x + y)
catmathjax(x + y)

catmath(x - y)
catmathjax(x - y)

catmath(x*y)
catmathjax(x*y)

catmath(x/y)
catmathjax(x/y)

# Plus Minus
catmath(x %+-% y)
catmathjax(x %+-% y)

# %/%:
catmath(x %/% y)
catmathjax(x %/% y)

# %*%
catmath(x %*% y)
catmathjax(x %*% y)

# %.%
catmath(x %.% y)
catmathjax(x %.% y)
```

### Juxtaposition

```{r results="asis"}
catmath(x[i])
catmathjax(x[i])

catmath(x^2L)
catmathjax(x^2L)

catmath(paste(x, y, z))
catmathjax(paste(x, y, z))
```

### Radicals

```{r results="asis"}
catmath(sqrt(x))
catmathjax(sqrt(x))

# It works, but it is NOT correct
catmath(sqrt(x, y))
catmathjax(sqrt(x, y))
```

### Relations

```{r results="asis"}
# # ~: without percentages, we already had ~
catmath(X ~ Y)
catmathjax(X ~ Y)

catmath(x==y)
catmathjax(x==y)

catmath(x < y)
catmathjax(x < y)

catmath(x <= y)
catmathjax(x <= y)

catmath(x >= y)
catmathjax(x >= y)

catmath(!x)
catmathjax(!x)

catmath(x != y)
catmathjax(x != y)

# # ~ ~: Check in mathml.R if it makes sense
catmath(x %~~% y)
catmathjax(x %~~% y)

# # = =: Check in mathml.R if it makes sense
catmath(x %==% y)
catmathjax(x %==% y)

# # ~ =: Check in mathml.R if it makes sense
catmath(x %=~% y)
catmathjax(x %=~% y)

# # prop: Check in mathml.R if it makes sense
catmath(x %prop% y)
catmathjax(x %prop% y)
```


```{r results="asis"}
# # plain(x): NOT WORKING
# catmath(plain(x))
# catmathjax(plain(x))

# # bold(x): NOT WORKING
# catmath(bold(x))
# catmathjax(bold(x))

# # italic(x): NOT WORKING
# catmath(italic(x))
# catmathjax(italic(x))

# # bolditalic(x): NOT WORKING
# catmath(bolditalic(x))
# catmathjax(bolditalic(x))

# # symbol(x): NOT WORKING
# catmath(symbol(x))
# catmathjax(symbol(x))

# It works, but it is NOT correct
catmath(list(x, y, z))
catmathjax(list(x, y, z))

# It works, but it is NOT correct
catmath(cdots)
catmathjax(cdots)

# Idem
catmath(ldots)
catmathjax(ldots)

# x %subset% y: NOT WORKING
# catmath(symbol(x %subset% y))
# catmathjax(symbol(x %subset% y))

# x %subsetq% y: NOT WORKING
# catmath(symbol(x %subsetq% y))
# catmathjax(symbol(x %subsetq% y))

# x %notsubset% y: NOT WORKING
# catmath(symbol(x %notsubset% y))
# catmathjax(symbol(x %notsubset% y))

# x %supset% y: NOT WORKING
# catmath(symbol(x %supset% y))
# catmathjax(symbol(x %supset% y))

# x %supsetq% y: NOT WORKING
# catmath(symbol(x %supsetq% y))
# catmathjax(symbol(x %supsetq% y))

# x %in% y: NOT WORKING
# catmath(symbol(x %in% y))
# catmathjax(symbol(x %in% y))

# x %notin% y: NOT WORKING
# catmath(symbol(x %notin% y))
# catmathjax(symbol(x %notin% y))

catmath(hat(x))
catmathjax(hat(x))

catmath(hat(xy))
catmathjax(hat(xy))

catmath(hat(xyz))
catmathjax(hat(xyz))


# tilde(x): NOT WORKING
# catmath(tilde(x))
# catmathjax(tilde(x))

# dot(x): NOT WORKING
# catmath(dot(x))
# catmathjax(dot(x))

# ring(x): NOT WORKING
# catmath(ring(x))
# catmathjax(ring(x))

# bar(x): NOT WORKING
# catmath(bar(x))
# catmathjax(bar(x))

# widehat(x): NOT WORKING
# catmath(widehat(x))
# catmathjax(widehat(x))

# widetilde(x): NOT WORKING
# catmath(widetilde(x))
# catmathjax(widetilde(x))

# x %<->% y
catmath(x %<->% y)
catmathjax(x %<->% y)

# x %->% y
catmath(x %->% y)
catmathjax(x %->% y)

# x %<-% y
catmath(x %<-% y)
catmathjax(x %<-% y)

# x %up% y: 
catmath(x %up% y)
catmathjax(x %up% y)

# x %down% y: 
catmath(x %down% y)
catmathjax(x %down% y)

# x %<=>% y: ACHTUNG I solved it using iff
catmath(x %<=>% y)
catmathjax(x %<=>% y)

# x %=>% y: ACHTUNG I solved it using rArr
catmath(x %=>% y)
catmathjax(x %=>% y)

# x %<=% y:  ACHTUNG I solved it using lArr
catmath(x %<=% y)
catmathjax(x %<=% y)

# x %dblup% y: 
catmath(x %dblup% y)
catmathjax(x %dblup% y)

# x %dbldown% y: 
catmath(x %dbldown% y)
catmathjax(x %dbldown% y)

# It works, but it is NOT correct
catmath(theta1)
catmathjax(theta1)

# It works, but it is NOT correct
catmath(Upsilon1)
catmathjax(Upsilon1)

# It works, but it is NOT correct
catmath(aleph)
catmathjax(aleph)

# It works, but it is NOT correct
catmath(infinity)
catmathjax(infinity)

# It works, but it is NOT correct
catmath(partialdiff)
catmathjax(partialdiff)

# It works, but it is NOT correct
catmath(nabla)
catmathjax(nabla)

# It works, but it is NOT correct
catmath(32L*degree)
catmathjax(32L*degree)

# It works, but it is NOT correct
catmath(60L*minute)
catmathjax(60L*minute)

# It works, but it is NOT correct
catmath(30L*second)
catmathjax(30L*second)

# # It doesn't work
# catmath(displaystyle(x))
# catmathjax(displaystyle(x))
# 
# # It doesn't work
# catmath(textstyle(x))
# catmathjax(textstyle(x))
# 
# # It doesn't work
# catmath(scriptstyle(x))
# catmathjax(scriptstyle(x))
# 
# # It doesn't work
# catmath(scriptscriptstyle(x))
# catmathjax(scriptscriptstyle(x))
# 
# # It doesn't work
# catmath(underline(x))
# catmathjax(underline(x))

# It works, but it is NOT correct
catmath(x ~~ y)
catmathjax(x ~~ y)

# # It doesn't work
# catmath(x + phantom(0) + y)
# catmathjax(x + phantom(0) + y)

catmath(frac(x, y))
catmathjax(frac(x, y))


catmath(over(x, y))
catmathjax(over(x, y))

# # It doesn't work
# catmath(atop(x, y))
# catmathjax(atop(x, y))


catmath(sum(x[i], i==1L, n))
catmathjax(sum(x[i], i==1L, n))

# # It doesn't work
# catmath(prod(plain(P)(X==x), x))
# catmathjax(prod(plain(P)(X==x), x))

# # It doesn't work
# catmath(integral(f(x)*dx, a, b))
# catmathjax(integral(f(x)*dx, a, b))

# # It doesn't work
# catmath(union(A[i], i==1, n))
# catmathjax(union(A[i], i==1, n))

# # It doesn't work 
# catmath(intersect(A[i], i==1, n))
# catmathjax(intersect(A[i], i==1, n))

# It doesn't work
# catmath(lim(f(x), x %->% 0))
# catmathjax(lim(f(x), x %->% 0))

g <- function(x)
# Catmath doesn't produce the output though
catmath(min(g(x), x > 0L))
catmathjax(min(g(x), x > 0L))

# # It doesn't work
# catmath(inf(S))
# catmathjax(inf(S))

# # It doesn't work
# catmath(sup(S))
# catmathjax(sup(S))


catmath(x^y + z)
catmathjax(x^y + z)

catmath(x^(y + z))
catmathjax(x^(y + z))

# without parenthesis
mathml(canonical(call("^", as.symbol("x"), call("+", as.symbol("y"), as.symbol("z")))))
mathjax(canonical(call("^", as.symbol("x"), call("+", as.symbol("y"), as.symbol("z")))))

# shortcut
catmath(x^{y + z})
catmathjax(x^{y + z})

# # It doesn't work
# catmath(group("(",list(a, b),"]"))
# catmathjax(group("(",list(a, b),"]"))

# # It doesn't work
# catmath(bgroup("(",atop(x,y),")"))
# catmathjax(bgroup("(",atop(x,y),")"))

# # It doesn't work
# catmath(group(lceil, x, rceil))
# catmathjax(group(lceil, x, rceil))

# # It doesn't work
# catmath(group(lfloor, x, rfloor))
# catmathjax(group(lfloor, x, rfloor))

# # It doesn't work
# catmath(group(langle, list(x, y), rangle))
# catmathjax(group(langle, list(x, y), rangle))


catmathjax(x && y)
catmathjax(x %/% y)

catmathjax(x <- y)


# How can we nicely render a vector?
vec <- 1:3
mathml(canonical(vec))
mathjax(canonical(vec))

# How can we nicely render a matrix?
# This is what I obtain: <math><mi>mat</mi></math> or ${mat}$
mat <- matrix(data = c(2L, 3L, 4L, 5L), nrow = 2, ncol = 2)
mathml(canonical(mat))
mathjax(canonical(mat))

# catmath(x %~~% y) This one produces an error
catmath(x ~~ y) # This one doesn't do what is supposed to do

```


# Appendix

## Some examples
```{r, results="asis"}
catmath(a["x"])
catmathjax(a["x"])

catmath(a^x)
catmathjax(a^x)

catmath(x["b"]^"a")
catmathjax(x["b"]^"a")

catmath(hat(b))
catmathjax(hat(b))

catmath(mean(x))
catmathjax(mean(x))

```



## Package base

```{r, results="asis"}
catmath("text")
catmathjax("text")

catmath(pi)
catmathjax(pi)

catmath(K %in% cal(K))
catmathjax(K %in% cal(K))

catmath(abs(x))
catmathjax(abs(alpha))

catmath(sign(x))
catmathjax(sign(alpha))

catmath(sqrt(2L))
catmathjax(sqrt(alpha))

catmath(sin(pi/2L))
catmathjax(sin(pi/2L))

catmath(cos(pi/2L))
catmathjax(cos(pi/2L))

catmath(tan(pi/2L))
catmathjax(tan(pi/2L))

catmath(asin(1L/2L * sqrt(2L)))
catmathjax(asin(1L/2L * sqrt(2L)))

catmath(acos(1L/2L * sqrt(2L)))
catmathjax(acos(1L/2L * sqrt(2L)))

catmath(atan(1L/2L * sqrt(2L)))
catmathjax(atan(1L/2L * sqrt(2L)))

catmath(atan2(1L, sqrt(3L)))
catmathjax(atan2(1L, sqrt(3L)))

catmath(sinpi(2L))
catmathjax(sinpi(2L))

catmath(cospi(2L))
catmathjax(cospi(2L))

catmath(tanpi(2L))
catmathjax(tanpi(2L))

catmath(sinh(x))
catmathjax(sinh(x))

catmath(cosh(x))
catmathjax(cosh(x))

catmath(tanh(x))
catmathjax(tanh(x))

catmath(asinh(x))
catmathjax(asinh(x))

catmath(acosh(x))
catmathjax(acosh(x))

catmath(atanh(x))
catmathjax(atanh(x))

catmath(all(x))
catmathjax(all(x))

catmath(any(x))
catmathjax(any(x))

catmath(besselI(x, nu))
catmathjax(besselI(x, nu))

catmath(besselK(x, nu))
catmathjax(besselK(x, nu))

catmath(besselJ(x, nu))
catmathjax(besselJ(x, nu))

catmath(besselY(x, nu))
catmathjax(besselY(x, nu))

catmath(beta(a, b))
catmathjax(beta(a, b))

catmath(lbeta(a, b))
catmathjax(lbeta(a, b))

catmath(gamma(x))
catmathjax(gamma(x))

catmath(lgamma(x))
catmathjax(lgamma(x))

# fixme: braces not needed
catmath(psigamma(x, deriv=psi))
catmathjax(psigamma(x, deriv=psi))

# fixme: braces not needed when right to *
catmath(a * log(b))

# fixme: dot is sufficient
catmath(log(b) * a)

# fixme: braces not needed when right to *
catmath(a * sum(b))

# paren needed
catmath(sum(b) * a)

# paren needed
catmath(sum(b) * sum(a))

catmath(digamma(x))
catmathjax(digamma(x))

catmath(trigamma(x))
catmathjax(trigamma(x))

catmath(choose(n, k))
catmathjax(choose(n, k))

catmath(choose(k=K, n=N))
catmathjax(choose(k=K, n=N))

catmath(lchoose(n, k))
catmathjax(lchoose(n, k))

catmath(factorial(x))
catmathjax(factorial(x))

catmath(lfactorial(x))
catmathjax(lfactorial(x))

catmath(A & B)
catmathjax(A & B)

catmath(A | B)
catmathjax(A | B)

catmath(!A)
catmathjax(!A)

catmath(xor(A, B))
catmathjax(xor(A, B))

catmath(exp(2L*pi*i))
catmathjax(exp(2L*pi*i))

catmath(expm1(2L*pi*i))
catmathjax(expm1(2L*pi*i))

catmath(log(x))
catmathjax(log(x))

catmath(log10(x))
catmathjax(log10(x))

catmath(log2(x))
catmathjax(log2(x))

catmath(logb(x, e))
catmathjax(logb(x, e))

catmath(log1p(x))
catmathjax(log1p(x))

catmath(ceiling(pi))
catmathjax(ceiling(pi))

catmath(floor(pi))
catmathjax(floor(pi))

f <- as.function(alist(a=, b=2, a+b))
mathml(canonical(f))
mathjax(canonical(f))

f <- function(x) sin(x)
mathml(canonical(f))
mathjax(canonical(f))

f <- function(x) { sin(x)}
mathml(canonical(f))
mathjax(canonical(f))

f <- function(x) { sin(x) ; tan(x) }
mathml(canonical(f))
mathjax(canonical(f))

f <- function(x) { sin(x) ; tan(x) }
mathml(canonical(f))
mathjax(canonical(f))

catmath(identical(1L, 2L))
catmathjax(identical(1L, 2L))

catmath(ifelse(a > b, a, b))
catmathjax(ifelse(a > b, a, b))

catmath(a %in% A)
catmathjax(a %in% A)

catmath(intersect(A, B))
catmathjax(intersect(A, B))

catmath(union(A, B))
catmathjax(union(A, B))

catmath(is.null(intersect(A, B)))
catmathjax(is.null(intersect(A, B)))

catmath(a:b)
catmathjax(a:b)

catmath(setdiff(A, B))
catmathjax(setdiff(A, B))

catmath(X %x% Y)
catmathjax(X %x% Y)

catmath(a*b + c/d - e %*% f)
catmathjax(a*b + c/d - e %*% f)

catmath(crossprod(A, B))
catmathjax(crossprod(A, B))

catmath(tcrossprod(A, B))
catmathjax(tcrossprod(A, B))

catmath(A ~ B)
catmathjax(A ~ B)

# not the desired result
X <- rnorm(5)
catmath(sum(X))
catmathjax(sum(X))

# this yields the desired result
X <- rnorm(5)
i <- seq_along(X)
catmath(sum(X[i]))
catmathjax(sum(X[i]))

catmath(subsupscript(sub=`=`(i, 1L), sup=N, fun=sum(X[i])))
catmathjax(subsupscript(sub=`=`(i, 1L), sup=N, fun=sum(X[i])))

catmath(L == prod(L[i]))
catmathjax(L == prod(L[i]))

catmath(mean(X) == sum(X[i])/N)
catmathjax(mean(X) == sum(X[i])/N)

# fixme, paren not needed
catmath(mean(X) == sum(X[i]/N))
catmathjax(mean(X) == sum(X[i]/N))

catmath(subsupscript(sub=`=`(i, 1L), sup=N, fun=prod(X[i])))
catmathjax(subsupscript(sub=`=`(i, 1L), sup=N, fun=prod(X[i])))

catmath(min(X[i]))
catmathjax(min(X[i]))

catmath(max(X[i]))
catmathjax(max(X[i]))

catmath((t(X)*X)^-1L*t(X)*y)
catmathjax((t(X)*X)^-1L*t(X)*y)

N = 20
k = 0:N
alpha = 0.05
catmath(c["lower"] == which.max(pbinom(k, N, pi) <= alpha))
catmathjax(c["lower"] == which.max(pbinom(k, N, pi) <= alpha))

catmath(c["upper"] == which.min(1L-pbinom(k, N, pi) <= alpha))
catmathjax(c["upper"] == which.min(1L-pbinom(k, N, pi) <= alpha))

#
# Schwarz (1994), Eq. 10
#
f <- function(tau)
{
  dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"])) * 
    (pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau))) * (mu["A"]*tau - c)
     - exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L)) *
       pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau))) * (mu["A"]*tau + c))
}

mathml(f)
mathjax(f)

# todo 0.6: package stats (e.g., integrate)
# todo 0.7: case study
# todo 0.8: generate expressions for Rd file
# todo 0.9: RJ paper, see Sarkar2022
```

# References
