---
title: "mathml: Translate R expressions to MathML"
author: "Matthias Gondan (Department of Psychology, University of Innsbruck, Austria)"
date: "2022-07-24"
bibliography: bibliography.bibtex
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rolog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

````{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(rmarkdown.html_vignette.check_title=FALSE)
library(mathml)
````

  Matthias Gondan\
  Department of Psychology\
  University of Innsbruck\
  Innrain 9\
  A-6020 Innsbruck\
  Matthias.Gondan-Rochon@uibk.ac.at
  
# Abstract

123

## Keywords

HTML; MathML; R

# 1. mathml: Translate R expressions to MathML

The R extension of the markdown language [@Xie2020] enables reproducible
statistical reports with nice typesetting in HTML, Microsoft Word, and Latex.
However, so far, R expressions such as `pbinom(k, N, p)` are printed as-is; 
prettier mathematical expressions such as $P_\mathrm{Bi}(X \le k; N, p)$ require
Latex commands like `P_\mathrm{Bi}\left(X \le k; N, p\right)`. Except for
minimalistic examples, these commands are tedious to type in and hard to read in
the original code. Since recently [@R, version 4.2], manual pages include
support for mathematical expressions [@Sarkar2022], which already is a big
improvement. Rules for the translation of R's built-in language elements to
their mathematical representation are lacking.

In this R package, such rules are defined for the _automatic_ translation of R
expressions mathematical output. The translation is done by an embedded
Prolog interpreter that maps nested expressions recursively to MathML and
LaTeX/MathJax, respectively, for typesetting of R Markdown documents in
different formats or ShinyApp webpages. User-defined hooks enable to extend the
set of rules and/or replace specific R elements by special mathematical signs.

## User-defined hooks

Mathematical expressions are typically rather concise, with a limited set of
identifiers for variables and functions (e.g., \(f(x)\)). In contrast, typical
R programs use informative names for variables and functions. As illustrated in
the example below, the one-to-one translation of these variable and function
names to MathML/MathJax often yields aesthetically unsatisfactory results.

````{r, results="asis"}
term <- quote(pbinom(successes, size, prob))
mathml(term)
````

The situation can be improved by user-defined hooks that map individual elements
to prettier mathematical counterparts.

````{r, results="asis"}
hook(quote(successes), quote(k))
hook(quote(size), quote(N))
hook(quote(prob), quote(pi))

term <- quote(pbinom(successes, size, prob))
mathml(term)
````

If the hooks apply to individual elements as in the example above, every
subsequent occurrence of `successes` will be translated to \(k\), which may not
be desired. More complex hooks allow to restrict such replacements to specific
terms, such as replacement of `s1` to \(k\) only if `s1` occurs as the first
argument of `pbinom`, as shown below.

````{r, results="asis"}
hook(call("pbinom", quote(s1), expression(Size), expression(Prob)), 
     call("pbinom", quote(k), expression(Size), expression(Prob)))

term <- quote(dbinom(s1, N, p))
mathml(term)
term <- quote(pbinom(s1, N, p))
mathml(term)
````

Note that the `s1` in `dbinom` is left untouched.

# Discussion

The result can then be used for calculations or it can be
rendered on a web page. A limited set of rules for translation from R to MathML
is found in `pl/mathml.pl` of the rolog package. The relevant code snippets are
shown in the listings below, along with their output.

```{r, results="asis"}
library(mathml)

term <- quote(pbinom(k, N, p))
hook(quote(p), quote(pi))
mathml(term)

# Do some calculations with the same term
k = 10
N = 22
p = 0.4
eval(term)
```


```{r}
catmath <- function(term)
{
  s <- substitute(term)
  c <- canonical(s)
  mathml(c)
}

catmathjax <- function(term)
{
  s <- substitute(term)
  c <- canonical(s)
  mathjax(c)
}
```

# Package base

```{r, results="asis"}
catmath("text")
catmathjax("text")

catmath(pi)
catmathjax(pi)

catmath(K %in% cal(K))
catmathjax(K %in% cal(K))

catmath(abs(x))
catmathjax(abs(alpha))

catmath(sign(x))
catmathjax(sign(alpha))

catmath(sqrt(2L))
catmathjax(sqrt(alpha))

catmath(sin(pi/2L))
catmathjax(sin(pi/2L))

catmath(cos(pi/2L))
catmathjax(cos(pi/2L))

catmath(tan(pi/2L))
catmathjax(tan(pi/2L))

catmath(asin(1L/2L * sqrt(2L)))
catmathjax(asin(1L/2L * sqrt(2L)))

catmath(acos(1L/2L * sqrt(2L)))
catmathjax(acos(1L/2L * sqrt(2L)))

catmath(atan(1L/2L * sqrt(2L)))
catmathjax(atan(1L/2L * sqrt(2L)))

catmath(atan2(1L, sqrt(3L)))
catmathjax(atan2(1L, sqrt(3L)))

catmath(sinpi(2L))
catmathjax(sinpi(2L))

catmath(cospi(2L))
catmathjax(cospi(2L))

catmath(tanpi(2L))
catmathjax(tanpi(2L))

catmath(sinh(x))
catmathjax(sinh(x))

catmath(cosh(x))
catmathjax(cosh(x))

catmath(tanh(x))
catmathjax(tanh(x))

catmath(asinh(x))
catmathjax(asinh(x))

catmath(acosh(x))
catmathjax(acosh(x))

catmath(atanh(x))
catmathjax(atanh(x))

catmath(all(x))
catmathjax(all(x))

catmath(any(x))
catmathjax(any(x))

catmath(besselI(x, nu))
catmathjax(besselI(x, nu))

catmath(besselK(x, nu))
catmathjax(besselK(x, nu))

catmath(besselJ(x, nu))
catmathjax(besselJ(x, nu))

catmath(besselY(x, nu))
catmathjax(besselY(x, nu))

catmath(beta(a, b))
catmathjax(beta(a, b))

catmath(lbeta(a, b))
catmathjax(lbeta(a, b))

catmath(gamma(x))
catmathjax(gamma(x))

catmath(lgamma(x))
catmathjax(lgamma(x))

# fixme: braces not needed
catmath(psigamma(x, deriv=psi))
catmathjax(psigamma(x, deriv=psi))

# fixme: braces not needed when right to *
catmath(a * log(b))

# fixme: dot is sufficient
catmath(log(b) * a)

# fixme: braces not needed when right to *
catmath(a * sum(b))

# paren needed
catmath(sum(b) * a)

# paren needed
catmath(sum(b) * sum(a))

catmath(digamma(x))
catmathjax(digamma(x))

catmath(trigamma(x))
catmathjax(trigamma(x))

catmath(choose(n, k))
catmathjax(choose(n, k))

catmath(choose(k=K, n=N))
catmathjax(choose(k=K, n=N))

catmath(lchoose(n, k))
catmathjax(lchoose(n, k))

catmath(factorial(x))
catmathjax(factorial(x))

catmath(lfactorial(x))
catmathjax(lfactorial(x))

catmath(A & B)
catmathjax(A & B)

catmath(A | B)
catmathjax(A | B)

catmath(!A)
catmathjax(!A)

catmath(xor(A, B))
catmathjax(xor(A, B))

catmath(exp(2L*pi*i))
catmathjax(exp(2L*pi*i))

catmath(expm1(2L*pi*i))
catmathjax(expm1(2L*pi*i))

catmath(log(x))
catmathjax(log(x))

catmath(log10(x))
catmathjax(log10(x))

catmath(log2(x))
catmathjax(log2(x))

catmath(logb(x, e))
catmathjax(logb(x, e))

catmath(log1p(x))
catmathjax(log1p(x))

catmath(ceiling(pi))
catmathjax(ceiling(pi))

catmath(floor(pi))
catmathjax(floor(pi))

f <- function(x) sin(x)
mathml(canonical(f))
mathjax(canonical(f))

catmath(function(x) sin(x))
catmathjax(function(x) sin(x))

catmath(function(x) {sin(x)})
catmathjax(function(x) {sin(x)})

catmath(function(x) {sin(x); cos(x)})
catmathjax(function(x) {sin(x); cos(x)})

catmath(identical(1L, 2L))
catmathjax(identical(1L, 2L))

catmath(ifelse(a > b, a, b))
catmathjax(ifelse(a > b, a, b))

catmath(a %in% A)
catmathjax(a %in% A)

catmath(intersect(A, B))
catmathjax(intersect(A, B))

catmath(union(A, B))
catmathjax(union(A, B))

catmath(is.null(intersect(A, B)))
catmathjax(is.null(intersect(A, B)))

catmath(a:b)
catmathjax(a:b)

catmath(setdiff(A, B))
catmathjax(setdiff(A, B))

catmath(X %x% Y)
catmathjax(X %x% Y)

catmath(a*b + c/d - e %*% f)
catmathjax(a*b + c/d - e %*% f)

catmath(crossprod(A, B))
catmathjax(crossprod(A, B))

catmath(tcrossprod(A, B))
catmathjax(tcrossprod(A, B))

catmath(A ~ B)
catmathjax(A ~ B)

# not the desired result
X <- rnorm(5)
catmath(sum(X))
catmathjax(sum(X))

# this yields the desired result
X <- rnorm(5)
i <- seq_along(X)
catmath(sum(X[i]))
catmathjax(sum(X[i]))

catmath(subsupscript(sub=`=`(i, 1L), sup=N, fun=sum(X[i])))
catmathjax(subsupscript(sub=`=`(i, 1L), sup=N, fun=sum(X[i])))

catmath(L == prod(L[i]))
catmathjax(L == prod(L[i]))

catmath(mean(X) == sum(X[i])/N)
catmathjax(mean(X) == sum(X[i])/N)

# fixme, paren not needed
catmath(mean(X) == sum(X[i]/N))
catmathjax(mean(X) == sum(X[i]/N))

catmath(subsupscript(sub=`=`(i, 1L), sup=N, fun=prod(X[i])))
catmathjax(subsupscript(sub=`=`(i, 1L), sup=N, fun=prod(X[i])))

catmath(min(X[i]))
catmathjax(min(X[i]))

catmath(max(X[i]))
catmathjax(max(X[i]))

catmath((t(X)*X)^-1L*t(X)*y)
catmathjax((t(X)*X)^-1L*t(X)*y)

N = 20
k = 0:N
alpha = 0.05
catmath(c["lower"] == which.max(pbinom(k, N, pi) <= alpha))
catmathjax(c["lower"] == which.max(pbinom(k, N, pi) <= alpha))

catmath(c["upper"] == which.min(1L-pbinom(k, N, pi) <= alpha))
catmathjax(c["upper"] == which.min(1L-pbinom(k, N, pi) <= alpha))

# todo 0.5: function bodies, use case: Schwarz Eq. 10 with mistake
# todo 0.6: package stats (e.g., integrate)
# todo 0.7: case study
# todo 0.8: generate expressions for Rd file
# todo 0.9: RJ paper, see Sarkar2022
```

# References
