---
title: "mathml: Translate R expressions to MathML and LaTeX/MathJax"
date: "2022-12-09"
abstract: >
  This R\ package translates R\ objects to suitable elements in MathML or LaTeX,
  thereby allowing for a pretty mathematical representation of R\ objects and
  functions in data analyses, scientific reports and interactive web content. In
  the RMarkdown document rendering language, R\ code and mathematical content
  already exist side-by-side. The present package allows to use the same
  R\ objects for both data analysis and typesetting in documents or web content.
  This tightens the link between the statistical analysis and its verbal
  description or symbolic representation, which is another step towards
  reproducible science. User-defined hooks allow to extend the package by
  mapping specific variables or functions to new MathML and LaTeX entities. A
  few working examples illustrate the use of the package in a scientific report
  and in on an interactive web page.
draft: true
author:  
  # see ?rjournal_article for more information
  - name: Matthias Gondan
    affiliation: University of Innsbruck
    address:
    - Department of Psychology
    - Innsbruck, Austria
    url: https://www.uibk.ac.at/psychologie/mitarbeiter/gondan-rochon/index.html.en
    orcid: 0000-0001-9974-0057
    email:  Matthias.Gondan-Rochon@uibk.ac.at
  - name: Irene Alfarone
    url: https://www.uibk.ac.at/psychologie/mitarbeiter/alfarone/index.html.en
    email: Irene.Alfarone@uibk.ac.at
    orcid: 0000-0002-8409-8900
    affiliation: University of Innsbruck
    address:
    - Department of Psychology
    - Innsbruck, Austria
type: package
output: 
  rjtools::rjournal_web_article:
    self_contained: yes
    toc: no
bibliography: RJreferences.bib
preamble:
- \usepackage{longtable}
- \usepackage{cancel}
Vignette: >
  %\VignetteIndexEntry{mathml}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
# To do
#
# paste(x, y, z)
# Spacing
# Comma separated lists
# Ellipsis
# Radicals
# Subsets
# Greek letters in MathJax
# Typeface
# Stylechanges
# Phantoms

library(mathml)
library(plotly)
library(ggplot2)
library(kableExtra)

mathout <- function(..., flags=NULL)
{
  if(knitr::is_html_output())
    return(mathml(..., flags=c(flags, list(cat=TRUE))))

  if(knitr::is_latex_output())
    return(mathjax(..., flags=c(flags, list(cat=TRUE))))

  warning("no output specified")  
  mathjax(..., flags=c(flags, list(cat=TRUE)))
}

catmath <- function(term, ...)
{
  s <- substitute(term)
  mathout(canonical(s), ...)
}
```

# Introduction

The R\ extension of the markdown language [@Xie2020] enables reproducible
statistical reports with nice typesetting in HTML, Microsoft Word, and Latex.
Since recently [@R, version 4.2], R\'s manual pages include support for
mathematical expressions [@Sarkar2022], which already is a big improvement.
However, rules for the mapping of built-in language elements to their
mathematical representation are still lacking. So far, R\ expressions such
as `pbinom(k, N, p)` are printed as they are; pretty mathematical formulae
such as \(P_\mathrm{Bi}(X \le k; N, p)\) require explicit Latex commands, that
is, `P_\mathrm{Bi}\left(X \le k; N, p\right)`. Except for minimalistic examples,
these commands are tedious to type in and their source code is hard to read.

The present R\ package defines a set of rules for the automatic translation of
R\ expressions to mathematical output in RMarkdown documents [@Xie2020] and
ShinyApp webpages [@Chang2022]. The translation is done by an embedded Prolog
interpreter that maps nested expressions recursively to MathML and
LaTeX/MathJax, respectively. User-defined hooks enable to extend the set of
rules, for example, to represent specific R\ elements by custom mathematical
signs.

The main feature of the package is that the same R\ expressions and equations
can be used for both mathematical typesetting and calculations. This saves time
and reduces mistakes, as will be illustrated below.

The paper is organized as follows. Section\ 2 presents the technical background
of the package, including the two main classes of Prolog rules for translating
R\ objects to mathematical expressions. Section\ 3 illustrates the main features
of the \pkg{mathml} package, potential issues and workarounds using examples
from the day-to-day perspective of a user. Sections\ 4 and\ 5 present two case
studies for the use of the package in a scientific report and a ShinyApp web
page. Section\ 6 concludes with a discussion and ideas for further development.
A complete list of the R\ elements covered by the package is found in the
Appendix.

# Background

The translation of R\ expressions to mathematical output is achieved through a
Prolog interpreter. Prolog is a classical logic programming language with many
applications in expert systems, computer linguistics and symbolic artificial
intelligence. The main strength of Prolog is its concise representation of facts
and rules for the representation of knowledge and grammar, as well as its
efficient built-in search engine for closed world domains. As it is well-known,
R\ is a statistical programming language for data analysis and statistical
modeling which is widely used in academia and industry. Besides the core
library, a lot of packages have been developed for all kinds of statistical
problems, including statistics-based artificial intelligence tools such as
neural networks for machine learning and deep learning. Whereas Prolog is weak
in statistical computation, but strong in symbolic manipulation, the converse
may be said for the R\ language. The \pkg{rolog} package [@rolog] bridges this
gap by providing an interface to a SWI-Prolog distribution in R. The
communication between the two systems is mainly in the form of queries from
R\ to Prolog, but two predicates allow Prolog to ring back and evaluate terms in
R.

For a first illustration of the \pkg{mathml} package, we consider the binomial
probability.

```{r}
term <- quote(pbinom(k, N, p))
term
```

The term is quoted to avoid its immediate evaluation (which would raise an error
anyway since the variables `k`, `N`, `p` have not yet been defined). Experienced
readers will remember that the quoted expression above is a short form for

```r
term <- call("pbinom", as.name("k"), as.name("N"), as.name("p"))
```

As is seen from the output above, the variable `term` is not assigned the result
of the calculation, but an R\ "call"
[see, e.g., @Wickham2019, for details on "non-standard evaluation"]. This call
can eventually be evaluated with `eval()`,

```{r}
k <- 10
N <- 22
p <- 0.4
eval(term)
```

The R\ package \pkg{mathml} can now be used to render the call in MathML, that
is the dialect for mathematical elements on HTML webpages or in MathJax/LaTeX,
as shown below (some of the curly braces are not really needed in this simple
example, but are necessary in edge cases).

```{r}
library(mathml)
mathjax(term)
```

We can include the output in a RMarkdown document by specifying `results='asis'`
in the R\ code chunk, as is done in the next example. The
R\ function `mathout()` is a wrapper that invokes `mathml()` for HTML output
and `mathjax()` for LaTeX output.

```{r, results='asis'}
mathout(term)
```

At the Prolog end, a predicate `math/2` translates the call `pbinom(K, N, Pi)`
into a "function" `fn/2` with the name `P_Bi`, one argument `X =< K`, and the
two parameters `N` and `Pi`.

```prolog
math(pbinom(K, N, Pi), M)
 => M = fn(subscript('P', "Bi"), (['X' =< K] ; [N, Pi])).
```

Thus, the predicate `math/2` could be considered a "macro" that translates a
mathematical element (here, `pbinom(K, N, Pi)`) to a different mathematical
element, namely `fn(Name, (Args ; Pars))`. The low-level predicate `ml/3` is
used to convert these basic elements to MathML.

```prolog
ml(Flags, fn(Name, (Args ; Pars)), M)
 => ml(Flags, Name, N),
    ml(Flags, paren(list(op(;), [list(op(','), Args), list(op(','), Pars)])), X),
    M = mrow([N, mo(&(af)), X]).
```

The relevant rule for `ml/3` builds the MathML entity `mrow([N, mo(&(af)), X])`,
with `N` representing the name of the function and `X` its arguments and
parameters, enclosed in parentheses. A corresponding rule `jax/3` does the same
for MathJax/LaTeX. A list of flags can be used for context-sensitive
translation (see, e.g., the errors below).

# Package \pkg{mathml} in practice

\pkg{mathml} is an R\ package for pretty mathematical representation of
R\ functions and objects in data analysis, scientific reports and interactive
web content. The currently supported features are listed below, roughly
following the order proposed by [@murrell2000].

## Basic elements

\pkg{mathml} handles the basic elements of everyday mathematical expressions,
such as numbers, Latin and Greek letters, multi-letter identifiers, accents,
subscripts, and superscripts. 
 
```{r, results='asis'}
term <- quote(1 + -2L + a + abc + "a" + phi + Phi + varphi + hat(b)[i, j]^2L)
mathout(term)

term <- quote(NaN + NA + TRUE + FALSE + Inf + (-Inf))
mathout(term)
```

An expression such as `1 + -2` may be considered unsatisfactory from an
aesthetical perspective. It is correct R\ syntax, though, and is reproduced
accordingly, without the parentheses. Parentheses around negated numbers or
symbols can be added as shown for `-Inf`.

Note that an R function `hat()` does not exist in base R, it is provided by the
package for convenience and points to the identity function.

## Operators and parentheses

Arithmetic operators and parentheses are translated as they are, as illustrated
below.

```{r, results="asis"}
term <- quote(a - ((b + c)) - d*e + f*(g + h) + i/j + k^(l + m) + (n*o)^{p + q})
mathout(term)

term <- quote(dot(d, e) + nodot(f, g + h) + times(X, Y))
mathout(term)
```

For multiplications involving only numbers and symbols, the multiplication sign
is omitted. This heuristic does not always produce the desired result;
therefore, \pkg{mathml} defines alternative multiplication
functions `dot()`, `nodot()`, and `times()` that produce the respective
multiplication signs.

For standard operators with known precedence, \pkg{mathml} is generally able to
detect if parentheses are needed; for example, parentheses are automatically
placed around `g + h` in the `nodot`-example. However, we note unecessary
parentheses around `l + m` above. Thes parentheses are a consequence
of `quote(a^(b + c))` actually producing a nested R\ call of the
form `'^'(a, (b + c))` instead of `'^'(a, b + c)`:

```{r}
term <- quote(a^(b + c))
paste(term)
```

For the present purpose, this feature is unfortunate because extra parentheses
around `b + c` are not needed. The preferred result is obtained by using the
functional form `quote('^'(k, l + m))` of the power, or curly braces as a
workaround (see `p + q` above).

## Custom operators

Whereas in standard infix operators, the parentheses typically follow the rules
for precedence, undesirable results may be obtained in custom operators.

```{r, results='asis'}
term <- quote(mean(X) %+-% 1.96 * s / sqrt(N))
mathout(term)
term <- quote('%+-%'(mean(X), 1.96 * s / sqrt(N)))
term <- quote(mean(X) %+-% {1.96 * s / sqrt(N)})   # the same
mathout(term)
```

The example is a reminder that it is not possible to define the precedence of
custom operators in R, and that expressions with such operators are evaluated
strictly from left to right. As in the previous example, the solution is to
either use the functional form of the operator or a curly brace to enforce the
correct operator precedence.

More operators are shown in Table \@ref(tab:custom-operators), including the
suggestions by Murrell and Ihaka [-@murrell2000] for graphical annotations and
arrows in R\ figures.

```{r custom-operators, echo=FALSE}
op1 <- list(
  cross=quote(A %*% B),
  dot=quote(A %.% B),
  kronecker=quote(A %x% B),
  'integer division'=quote(A %/% B),
  and=quote(A & B),
  vel=quote(A | B),
  xor=quote(xor(A, B)),
  not=quote(!A),
  equal=quote(A == B),
  assign=quote(A <- B))

m1 <- lapply(op1, FUN=mathout, flags=list(cat=FALSE))

op1 <- as.character(op1)
if(knitr::is_latex_output())
  op1 <- sapply(op1, FUN=knitr:::escape_latex)
if(knitr::is_html_output())
  op1 <- sapply(op1, FUN=knitr:::escape_html)

op2 <- list(
  different=quote(A != B),
  tilde=quote(A ~ B),
  approx=quote(A %~~% B),
  equiv=quote(A %==% B),
  congr=quote(A %=~% B),
  prop=quote(A %prop% B),
  'in'=quote(A %in% B),
  intersect=quote(intersect(A, B)),
  union=quote(union(A, B)),
  intersect=quote(is.null(A)))

m2 <- lapply(op2, FUN=mathout, flags=list(cat=FALSE))

op2 <- as.character(op2)
if(knitr::is_latex_output())
  op2 <- sapply(op2, FUN=knitr:::escape_latex)
if(knitr::is_html_output())
  op2 <- sapply(op2, FUN=knitr:::escape_html)

op3 <- list(
  twosidearrow=quote(A %<->% B),
  rightarrow=quote(A %->% B),
  leftarrow=quote(A %<-% B),
  uparrow=quote(A %up% B),
  down=quote(A %down% B),
  iff=quote(A %<=>% B),
  rArr=quote(A %=>% B),
  lArr=quote(A %<=% B),
  dblup=quote(A %dblup% B),
  dbldown=quote(A %dbldown% B))

m3 <- lapply(op3, FUN=mathout, flags=list(cat=FALSE))

op3 <- as.character(op3)
if(knitr::is_latex_output())
  op3 <- sapply(op3, FUN=knitr:::escape_latex)
if(knitr::is_html_output())
  op3 <- sapply(op3, FUN=knitr:::escape_html)

t <- cbind(Operator=op1, Output=m1,
  Operator=op2, Output=m2,
  Operator=op3, Arrow=m3)

knitr::kable(t, caption="Custom operators in mathml",
  row.names=FALSE, escape=FALSE)
```

## Builtin functions

There is support for most functions from \pkg{base}, with adequate use and omission
of parentheses.

```{r, results='asis'}
term <- quote(sin(x) + sin(x)^2L + cos(pi/2L) + tan(2L*pi) * expm1(x))
mathout(term)
term <- quote(choose(N, k) + abs(x) + sqrt(x) + floor(x) + ceiling(x))
mathout(term)
```

A few more examples are shown in Table \@ref(tab:base-stats), including
functions from \pkg{stats}. 

```{r base-stats, echo=FALSE}
op1 <- list(
  sin=quote(sin(x)),
  cosh=quote(cosh(x)),
  tanpi=quote(tanpi(alpha)),
  log=quote(log(p)),
  log1p=quote(log1p(x)),
  exp=quote(exp(x)),
  expm1=quote(expm1(x)),
  lchoose=quote(lchoose(n, k)),
  sqrt=quote(sqrt(x)),
  mean=quote(mean(X)),
  absolute=quote(abs(x)))
m1 <- lapply(op1, FUN=mathout, flags=list(cat=FALSE))

op1 <- as.character(op1)
if(knitr::is_latex_output())
  op1 <- sapply(op1, FUN=knitr:::escape_latex)
if(knitr::is_html_output())
  op1 <- sapply(op1, FUN=knitr:::escape_html)

op2 <- list(
  dbinom=quote(dbinom(k, N, pi)),
  pbinom=quote(pbinom(k, N, pi)),
  qbinom=quote(qbinom(p, N, pi)),
  dnorm=quote(dnorm(x)),
  dnorm=quote(dnorm(x, mu, sigma)),
  pnorm=quote(pnorm(x)),
  pnorm=quote(pnorm(x, mu, sigma)),
  qnorm=quote(qnorm(alpha/2L)),
  pchisq=quote(1L-pchisq(x, 1L)),
  qchisq=quote(qchisq(1L-alpha, 1L)),
  pt=quote(pt(t, N-1L)),
  qt=quote(qt(alpha/2L, N-1L)))
m2 <- lapply(op2, FUN=mathout, flags=list(cat=FALSE))

op2 <- as.character(op2)
if(knitr::is_latex_output())
  op2 <- sapply(op2, FUN=knitr:::escape_latex)
if(knitr::is_html_output())
  op2 <- sapply(op2, FUN=knitr:::escape_html)

t <- cbind(Function=op1, Output=m1, Function=op2, Output=m2)
knitr::kable(t, caption="R functions from base and stats",
  row.names=FALSE, escape=FALSE)
```

## Custom functions

For self-written functions, matters are a bit more complicated. The name of a
self-written function is not transparent in R, since only the function body is
represented, as illustrated by the redefinition of `sign` below. The function is
often a nested R "call" of the form `'{'(L)`, with `L` being a list of
commands. \pkg{mathml} provides very limited support for typical control
structures.

```{r, results='asis'}
sgn <- function(x)
{
  if(x == 0L) return(0L)
  if(x < 0L) return(-1L)
  if(x > 0L) return(1L)
}

term <- quote(s <- sgn(x))
mathout(term)

hook(quote(s), quote(sg(x)))
term <- call("<-", quote(s), sgn)
mathout(term)
```

The hook (see below) is used to display \(\mathrm{sg}(x) = \{\ldots\) instead
of just \(s = \{\).

## Ringing back to R

R\'s `integrate` function takes a number of arguments, the most important ones
being the function to integrate, and the lower and the upper bound of the
integration.

```{r, results='asis'}
term <- quote(integrate(sin, 0L, 2L*pi))
mathout(term)
eval(term)
```

For mathematical typesetting in the form
of \(\int f(x)\, dx\), \pkg{mathml} needs to find out the name of the
integration variable. For that purpose, the underlying Prolog bridge provides a
predicate `r_eval/2` that calls R\ from Prolog. In the example above, this
predicate evaluates `formalArgs(args(sin))`, which returns the names of the
arguments of `sin`, namely, `x`.

Note that in the example above, the quoted term is an abbreviation
for `call("integrate", quote(sin), ...)`, with `sin` being an R\ symbol, not a
function. R's `integrate()` can handle both. However, as already mentioned in
the previous subsection, \pkg{mathml} would be unable to find out the function
name, it needs the symbol.

```{r, results='asis'}
g <- function(x)
  sin(x)

term <- quote(integrate(g, 0L, 2L*pi))
mathout(term, env=environment())
```

By default, `r_eval/2` evaluates the R call in the global environment. In some
situations, this may not be desired. For example, PDF articles for the
R\ Journal are generated in a separate environment, such that the function `g()`
defined above is not found. In the above example, the option `env=` explicitly
indicates the path to `g(x)`.

## Names and order of arguments

One of R's great features is the possibility to refer to function arguments by
their names, not only by their position in the list of arguments. At the other
end, most Prolog-powered handlers for the R\ calls are rather rigid, for
example, `integrate/3` accepts exactly three arguments in a particular order and
without names, that is, `integrate(lower=0L, upper=2L*pi, sin)`, would not print
the desired result.

To "canonicalize" function calls with named arguments and arguments in unusual
order, \pkg{mathml} provides an auxilliary R\ function `canonical(f, drop)` that
reorders the argument list of calls to known R\ functions and, 
if `drop=TRUE` (which is the default), also removes the names of the arguments.

```{r}
term <- quote(integrate(lower=0L, upper=2L*pi, sin))
canonical(term)
```

```{r, results='asis'}
mathout(canonical(term))
```

This function can be used to feed mixtures of partially named and positional
arguments into the renderer. For details, see the R\ function `match.call()`.

## Matrices and Vectors

Of course, \pkg{mathml} also supports matrices and vectors.

```{r, results='asis'}
v <- 1:3
mathout(call("t", v))

A <- matrix(data=11:16, nrow=2, ncol=3)
B <- matrix(data=21:26, nrow=2, ncol=3)
term <- call("+", A, B)
mathout(term)
```

Note that the seemingly more convient `term <- quote(A + B)` yields \(A + B\) in
the output---instead of the desired matrix representation.

## Customizing the package

In typical R\ functions, variable names are typically longer than just single
letters, which may yield unsatisfactory results in the mathematical output.

```{r, results='asis'}
term <- quote(pbinom(successes, Ntotal, prob))
mathout(term)
```

To improve the situation, \pkg{mathml} provides a simple hook into the prolog
predicate `math/2` described in the previous section.

```{r, results='asis'}
hook(quote(successes), quote(k))
hook(quote(Ntotal), quote(N))
hook(quote(prob), quote(pi))
mathout(term)
```

More complex hooks are possible. In the example below, `dnorm(X, M, S)` is
translated to the form `phi(X; M, S)` (instead of the default `varphi`).

```{r, results='asis'}
hook(call("dnorm", expression(X), expression(M), expression(S)), 
     call("fn", quote(phi),
       call(";", list(expression(X)), list(expression(M), expression(S)))))
term <- quote(dnorm(x, mu, sigma^2L))
mathout(term)
```

R's expressions are a bit misused to represent variables in the underlying
prolog engine.


## Operators

A list of possible operators is available here.

```{r, results='asis', echo=TRUE}
catmath(sum(x[i], i==1L, n))

# fixme: braces not needed when right to *
catmath(a * sum(b[i]))

# Multiplication (capital Pi) is missing
catmath(a * prod(b[i]))

catmath(integrate(sin, 0L, 2L*pi))

catmath(A & B)

catmath(A | B)

catmath(!A)

catmath(xor(A, B))

catmath(exp(2L*pi*i))

catmath(expm1(2L*pi*i))

catmath(log(x))

catmath(log10(x))

catmath(log2(x))

catmath(logb(x, e))

catmath(log1p(x))

catmath(ceiling(pi))

catmath(floor(pi))

catmath(sin(pi/2L))

catmath(cos(pi/2L))

catmath(tan(pi/2L))
```

## Grouping

At first glance, grouping expressions may seem trivial enough. However, when you want to deal with, for instance, exponentiation or multiplication, things can get more complicated. Let us consider a trivial example. If we want to calculate and evaluate the expression `a * (b + c)`, we find that R\ automatically gives precedence to the addition even if we do not specify it in the text, as in the following.

```{r, results='asis', echo=TRUE}
first <- quote(a)
second <- quote(b + c)
mathout(call("*", first, second))

# precedence
quote(a * (b + c))[[3]][[1]]
```

With exponentiation the situation can be less trivial. If we consider `x` to the power of `y + z`, following R\ notation we should add a parenthesis around the two terms. Otherwise R\ would consider only `y` as power of `x`.

```{r, results='asis', echo=TRUE}
catmath(x^y + z)

# mathout(call("+", call("^", as.symbol("x"), as.symbol("y")), as.symbol("z")))

catmath(x^(y + z))
```

Unfortunately, R\ automatically put `y + z` in parentheses even if, from a mathematical point of view, the brackets are not needed. To solve this issue two solutions are possible, the first one is cumbersome since it requires many specifications. The second, that can be considered a shortcut, uses a syntax similar to LateX and puts the power in curly brackets. In both cases the output produced is consistent with the mathematical notation.

```{r, results='asis', echo=TRUE}
# without parenthesis
mathout(canonical(call("^", as.symbol("x"), call("+", as.symbol("y"), as.symbol("z")))))

# shortcut
catmath(x^{y + z})
```


## Abbreviations

\pkg{mathml} allows also for the use of abbreviations in formulas. Let us consider here the t-statistic for independent samples with equal variance assumed. 
The procedure consists of three steps. The first one is to define the hooks to nicely print the variables. Second, we write the t-statistic specifying in the formula how to calculate the pooled variance with the function  `denote(abbr, expr, info)`.  Finally, since \pkg{mathml} also allows computation, we can directly compute the value of the t statistic with `eval()`.

```{r, results='asis', echo=TRUE}

hook(quote(x_1), quote(mean(x["1"])))
hook(quote(x_2), quote(mean(x["2"])))
hook(quote(n_1), quote(n["1"]))
hook(quote(n_2), quote(n["2"]))
hook(quote(s_1), quote(s["1"]))
hook(quote(s_2), quote(s["2"]))
hook(quote(s_p), quote(s["pool"]))


t <- quote(dfrac(x_1 - x_2, sqrt(denote(s_p^2L, frac((n_1 - 1L)*s_1^2L + (n_2 - 1L)*s_2^2L, n_1+n_2-2L), "the pooled variance.") * (dfrac(1L, n_1)+dfrac(1L,n_2)))))
  
mathout(t)

# An example

x_1 = 20.5
x_2 = 35.7
n_1 = 150
n_2 = 160
s_1 = 3.4
s_2 = 4.2

eval(t)
```


# A case study {#case-study}

For a more clear representation of what the \pkg{mathml} package is supposed to do, we provide here a case study, based on the work by Schwarz [-@schwarz1994], in which the features of \pkg{mathml} are implemented.

The reader may recognize that Schwarz' [-@schwarz1994] study can be traced back to the strand of decision-making models, where decision-making is assumed to be a process of
noisy accumulation of information over time [e.g., @ratcliff2016]. The aim of
Schwarz' [-@schwarz1994] study is to present a new explanation of redundancy gains when
observers make speeded responses to stimuli of different sources, and the same
information is presented on two channels. Schwarz [-@schwarz1994] describes a model that assumes
the superposition of channel-specific diffusion processes that eventually reach
an absorbing barrier to elicit the response. For a detailed description the
reader may refer to the original article.


### The model 

Schwarz' [-@schwarz1994] model refers to two stimuli A and B, presented either
alone or in combination (redundant stimuli), with the redundant stimuli being
presented either simultaneously or with onset asynchrony $\tau$. The channel
activation is described as a two-dimensional Wiener process with
drifts $\mu_\mathrm A$, $\mu_\mathrm B$,
variances $\sigma^2_\mathrm A$, $\sigma^2_\mathrm B$,
correlation $\rho_\mathrm{AB}$ and initial
conditions $X_i(t=0)=0, i=\mathrm{A, B}$. The response is elicited when the
process reaches the absorbing barrier $c > 0$ for the first time. In combined
stimuli ("redundant" stimuli), the overall diffusion process
is $X_\mathrm{AB}(t) = X_\mathrm A(t) + X_\mathrm B(t)$ , which is again a
Wiener process with drift $\mu_\mathrm A + \mu_\mathrm B$ and
variance $\sigma^2_\mathrm A + \sigma^2_\mathrm B
  + 2\rho_\mathrm{AB}\sigma_\mathrm A\sigma_\mathrm B$.

In single-target trials, the first passages at $c$ are expected at
$E\left[D_i\right] = \frac{c}{\mu_i}, i = \mathrm{A, B}$, whereas in synchronous
redundant-target trials, we have
$E[D_\mathrm{AB}]= \frac{c}{\mu_\mathrm A + \mu_\mathrm B}$.

For asynchronous stimuli, Schwarz [-@schwarz1994] derived the expected
first-passage time $E[D_{\mathrm A(\tau)\mathrm B}]$ as a function of the
stimulus onset asyncrony $\tau > 0$ (Eq.\ 10),

```{r, results="asis", echo=TRUE}
f <- function(tau, c, mu_A, sigma_A, mu_B, sigma_B)
{ dfrac(c, mu_A) + (dfrac(1L, mu_A) - dfrac(1L, mu_A + mu_B)) *
    ((mu_A*tau - c) * pnorm(dfrac(c - mu_A*tau, sqrt(sigma_A^2L*tau)))
      - (mu_A*tau + c) * exp(dfrac(2L*mu_A*c, sigma_A^2L))
        * pnorm(dfrac(-c - mu_A*tau, sqrt(sigma_A^2L*tau))))
}

mathout(f)
``` 


The observable response time is assumed to be the sum of $D$, the time
employed to reach the threshold for the decision, and $M$, denoting the of the
other processes.

$E[T]= E[D + M] = E[D] + E[M] = E[D] + \mu_M$

### Methods

Schwarz [-@schwarz1994] applied the model to Miller’s [-@miller1986] data from
a redundant signals task with 13 onset
asynchronies $0, \pm33, \pm67, \pm100, \pm133, \pm167, \pm\infty$ ms,
where 0 refers to synchronous AB, $\infty$ refers to the single-target
presentation, and negative $\tau$ denote those conditions in which B is
presented before A. Each condition was replicated 400 times. The 13 mean RTs and
standard deviations are given in Table 2 below.

Then, from Schwarz' [-@schwarz1994] Equations [2] [3] and [10], we calculated the expected first time passage for the respective $\tau$ and the parameters $\mu_ \mathrm A = 0.53, \mu_ \mathrm B = 1.32, \sigma_ \mathrm A = 4.43, \sigma_ \mathrm B = 18.3, c = 100, \mu_\mathrm M = 161$


````{r, echo=FALSE}
mu_A = 0.53
mu_B = 1.32
sigma_A = 4.4
sigma_B = 18.3
tau = c(-Inf, -167, -133, -100, -67, -33, 0, 33, 67, 100, 133, 167, Inf)
c = 100
mu_M = 161
````


```{r, results="asis", echo=FALSE}
# Conditions

g <- function(tau, c, mu_A, sigma_A, mu_B, sigma_B)
{
    if( tau == Inf) return(dfrac(c, mu_A));
    if( tau == -Inf) return(dfrac(c, mu_B));
    if( tau > 0L)  return(f(tau, c, mu_A, sigma_A, mu_B, sigma_B));
    if( tau == 0L) return(dfrac(c, mu_A + mu_B));
    if( tau < 0L) return(f(-tau, c,  mu_B, sigma_B, mu_A, sigma_A))
}

mathout(g)
```

For instance, we can see that with $\tau = -167$ the expected first passage time is:

```{r, echo=FALSE}
mu_A = 0.53
mu_B = 1.32
sigma_A = 4.4
sigma_B = 18.3
tau = -167
c = 100
mu_M = 161

g(tau, c, mu_A, sigma_A, mu_B, sigma_B)
```

To which we have to add $\mu_M = 161$ (which represents the amount of time that the movement of providing the answer takes) and we obtain:

```{r, echo=FALSE}
g(tau, c, mu_A, sigma_A, mu_B, sigma_B) + mu_M
```

Similarly, we obtain the first-time passage for every $\tau$:

```{r, results="asis", echo=FALSE}

G <- Vectorize(g, vectorize.args = 'tau')

h <- function(tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
{
  G(tau, c, mu_A, sigma_A, mu_B, sigma_B) + mu_M
}

mathout(h)
```

```{r, echo=FALSE}

mu_M = 161
mu_A = 0.53
mu_B = 1.32
sigma_A = 4.4
sigma_B = 18.3
tau = c(-Inf, -167, -133, -100, -67, -33, 0, 33, 67, 100, 133, 167, Inf)
c = 100

h(tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
```


### Model fitting and Parameters Estimation

Then we proceeded with the model fitting, using the data provided by Miller [-@miller1986] study in Schwarz [-@schwarz1994]. First, we calculated the predicted means RT as $E[RT]=E[T]+\mu_M$.

We briefly remind that in diffusion models there is across-trial variability, and the drift rates are assumed to be normally distributed [@ratcliff2008] with at the first passage of $c$ $X(t) \sim N(\mu t , \sigma^2 t)$. Where $T$ is expressed as $T= \arg \min_t X(t)\geq c$ with $T \sim IG (c, \mu, \sigma^2)$ with mean $E(T)=\displaystyle \frac{c}{\mu}$ and variance $Var(T)=\displaystyle \frac{c\sigma^2}{\mu^3}$. Furthermore, for the Central Limit Theorem $\bar{T} = \displaystyle \frac{\Sigma_iT_i}{N} \dot\sim N (\displaystyle \frac{c}{\mu} , \displaystyle \frac{c\sigma^2}{\mu^3})$

For these reasons, in order to obtain the Goodness of Fit measure we proceeded with a z-standardisation.

```{r, results="asis", echo=FALSE}
zf <-  function(M, s, N, tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
{
  E <- h(tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
  dfrac(M-E, s/sqrt(N))
}

mathout(zf)
```


```{r, echo=FALSE}
# The vector X contains the observed values, the vector s their observed standard deviation and N = 400 are the number of trials.

M = c(231, 234, 230, 227, 228, 221, 217, 238, 263, 277, 298, 316, 348)
s = c(56, 58, 40, 40, 32, 28, 28, 28, 26, 30, 32, 34, 92)
N = c(400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400)

zn <- zf(M, s, N, tau, c, mu_A, sigma_A, mu_B, sigma_B, mu_M)
zn
```

Then, we calculated the Goodness of Fit as follows:

$X^2=\Sigma_\tau z^2_\tau \sim\chi^2(13-5\  dgf)$.

```{r, results="asis", echo=FALSE}
par <- c(mu_A = 0.53, sigma_A = 4.4, mu_B = 1.32, sigma_B = 18.3, mu_M = 161)

# Goodness of Fit

gof <- function(par, tau, M, s, N)
{
  zn <- zf(M, s, N, tau, c=100L, mu_A=par["mu_A"], sigma_A=par["sigma_A"], mu_B=par["mu_B"], sigma_B=par["sigma_B"], mu_M=par["mu_M"])
  sum(zn^2L)
}

mathout(gof)
```

```{r, results="asis", echo=FALSE}
n <- gof(par, tau, M, s, N)
n
pchisq(n, 8, lower.tail = FALSE, log.p = FALSE)
```


```{r, results="asis", echo=FALSE}
lsq = function(tau, M, s, N)
{
  start = c(mu_A = 0.3, sigma_A = 2, mu_B = 1 , sigma_B = 5, mu_M = 200)
  optim(start, fn = gof,
    tau = tau, M = M, s = s, N = N, hessian = TRUE, control = list(fnscale = 1))
}

mathout(lsq)

# Parameters' estimates
fit <-  lsq(tau, M, s, N)

est = fit$par
se = sqrt(diag(solve(fit$hessian)))
cilo = qnorm(0.025, est, se)
ciup = qnorm(0.975, est, se)

# Lower bound
#cilo

# Upper bound
#ciup

```

### Results

The calculated Goodness of Fit value is $X^2= 30.54$, $p= 0.0002$. Additionally, we proceeded with the parameters' estimation with the Least Squares Method.

The values of the estimated parameters reported in the table below are consistent with those reported by Schwarz [-@schwarz1994].

```{r}
# Table 1: Estimated Model's Parameters
#
# | Parameters | Estimate | 95% Confidence Interval
# | :---: | :---: | :---:|
# | $ \mu_ \mathrm A $| 0.53 | 0.51, 0.56
# | $ \sigma_ \mathrm A $| 4.4 | 3.8, 5.1
# | $ \mu_ \mathrm B $| 1.32 | 1.2, 1.4
# | $ \sigma_ \mathrm B $| 18.3 | 11.6, 24.9
# | $ \mu_ \mathrm M $| 161 | 157, 165
```

Furthermore, we can observe from the values reported in the Table below that, with few exceptions (e.i. $\tau= 100$) Miller's [-@miller1986] observed values are quite similar to the one predicted by Schwarz' [-@schwarz1994] model. Showing that, despite the calculated Goodness of Fit measure, the model proposed by Schwarz [-@schwarz1994] sufficiently fit the data.

```{r}
# : Table 2: Predicted Means RT and Observed Means RT and SDs from Miller's [-@miller1986] study in Schwarz [-@schwarz1994]
#
# | SOA      | Predicted Mean RT | Observed Mean RT | Observed SD |
# |:--------:|:-----------------:|:----------------:|:-----------:|
# $-\infty$| 237 | 231 | 56 |
# $-167$   | 231 | 234 | 58 |
# $-133$   | 230 | 230 | 40 |
# $-100$   | 228 | 227 | 40 |
# $-67$    | 226 | 228 | 32 |
# $-33$    | 222 | 221 | 28 |
# $0$      | 215 | 217 | 28 |
# $33$     | 239 | 238 | 28 |
# $67$     | 262 | 263 | 26 |
# $100$    | 283 | 277 | 30 |
# $133$    | 300 | 298 | 32 |
# $167$    | 313 | 316 | 34 |
# $\infty$ | 350 | 348 | 92 |
#
# _Note_.  Parameters: $\mu_ \mathrm A = 0.53, \mu_ \mathrm B = 1.32, \sigma_ \mathrm A = 4.4, \sigma_ \mathrm B = 18.3, c = 100, \mu_\mathrm M = 161$
```

## Mistakes

The case study presented above displays several possible ways of how \pkg{mathml} can be a useful tool in data representation and calculation. Furthermore, the careful reader might have also noticed that \pkg{mathml} allows also for a more smoothly detection of possible mistakes in writing. 

An interesting use case of the package is in this sense the readability of self-written
functions in R\ code. R\ code is notoriously hard to read, as are most programming
languages [@green1977]. The poor legibility of the language is one of the main
sources of mistakes. For illustration, we consider Equation 10 in
Schwarz [-@schwarz1994], namely the same equation reported above. The first version has a wrong parenthesis, which is barely visible in the R code.

````{r, results="asis", echo=TRUE}
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"]) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))))
}

attributes(f)$name = quote(f)
mathout(f)
````

But, if the function is rendered in MathML, the wrong parenthesis appears as a curly
brace, and we immediately see the mistake. The correct version is shown below
for comparison.

````{r, results="asis", echo=TRUE}
f <- function(tau)
{ dfrac(c, mu["A"]) + (dfrac(1L, mu["A"]) - dfrac(1L, mu["A"] + mu["B"])) * 
    ((mu["A"]*tau - c) * pnorm(dfrac(c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau)))
      - (mu["A"]*tau + c) * exp(dfrac(2L*mu["A"]*tau, sigma["A"]^2L))
        * pnorm(dfrac(-c - mu["A"]*tau, sqrt(sigma["A"]^2L*tau))))
}

attributes(f)$name = quote(f)
mathout(f)
````

This example may seem trivial. However, as the reader well knows, a missed parenthesis is often the cause of untraceable errors and contradictory results. Thus, rendering the expression in MathMl improves the readability of the text, allowing better identification of the sources of possible errors. 

## Errors

An additional feature that this package offers is related to its application in educational scenarios. The functions here reported are intended to identify and highlight possible errors that students make, as well as provide the correct answer for the task.

In this first example the function highlights that the student forgot to add the left-hand side of the expression and it does that by striking the missing part. In this case the letter A and the operator `+`.
Similarly the function `omit_right` does the same for the omissions in the right-hand side of the expression. Finally the function `omit()` can be used, for instance, to highlight the omission in the elements of a list.

```{r, results="asis"}
t <- quote(omit_left(a + b))
mathout(t)
```

```{r, results="asis"}
t <- quote(omit_right(a + b))
mathout(t)
```

```{r, results="asis"}
t <- list(quote(a), quote(b), quote(omit(c)))
mathout(t)
```

```{r omit, echo=FALSE}
op <- list(left=quote(omit_left(a + b)), right=quote(omit_right(a + b)), list=quote(omit(c)))
m <- lapply(op, FUN=mathout, flags=list(cat=FALSE))

op <- as.character(op)
if(knitr::is_latex_output())
  op <- sapply(op, FUN=knitr:::escape_latex)
if(knitr::is_html_output())
  op <- sapply(op, FUN=knitr:::escape_html)

t <- cbind(Operator=op, Output=m)
knitr::kable(t, caption="Omit", row.names=FALSE, escape=FALSE)
```

The functions `add_left()`, `add_right()`, `add()` reported below follow the same way of reasoning, but they account for the mistakes made in adding incorrect elements in the expression. They highlight the redundant element placing it in a box. 

```{r, results="asis"}
t <- quote(add_left(a + b))
mathout(t)
```

```{r, results="asis"}
t <- quote(add_right(a + b))
mathout(t)
```

```{r, results="asis"}
t <- list(quote(a), quote(b), quote(add(c)), quote(d))
mathout(t)
```

```{r add, echo=FALSE}
op <- list(left=quote(add_left(a + b)), right=quote(add_right(a + b)))
m <- lapply(op, FUN=mathout, flags=list(cat=FALSE))

op <- as.character(op)
if(knitr::is_latex_output())
  op <- sapply(op, FUN=knitr:::escape_latex)
if(knitr::is_html_output())
  op <- sapply(op, FUN=knitr:::escape_html)
t <- cbind(Operator=op, Output=m)

knitr::kable(t, caption="Add", row.names=FALSE, escape=FALSE)
```

Finally the function `instead( , )` place a curly bracket under the incorrect element  and provides its correct version under the curly bracket. In order to provide the correction with this function one must fill it with its wrong and correct terms in this order: `instead(wrong, correct)`. An example of its use its provided below.

```{r, results="asis"}
t <- quote(instead(a, b) + c)
mathout(t)
```

It is also possible to use flags for context-dependent rendering. The `highlight` flag is the default one. It shows where the error is and what is its solution. The `ignore` flag allows the program to ignore the fact that there is an error and print the expression as if it were correct. The third flag, `fix`, tells you what is the term that you are supposed to fix without giving the solution. Finally, the last flag `asis` returns the incorrect expression as the student wrote it, without providing any solutions or corrections.  Below is provided the code with its comment and an example of use.

Let us consider for example a student that instead of writing `b + c` wrote `a+c`. 

With the `asis` flag we report the incorrect expression provided by the student: 

```{r, results="asis"}
# It prints the incorrect version
t <- quote(instead(a, b) + c)
mathout(t, flags=quote(error(asis)))
```

Then, we may want to underline the incorrect term and provide the correct solution. 

```{r, results="asis"}
# It highlights what has been mistakenly inserted
mathout(t, flags=quote(error(highlight))) # default
```

Alternatively, we can put the correct solution in a box to let the student focus on its correction.

```{r, results="asis"}
# It highlights what has been corrected
mathout(t, flags=quote(error(fix)))
```

Finally, we can simply provide the correct solution to the problem wit the flag `ignore`. 

```{r, results="asis"}
# It prints the correct version
mathout(t, flags=quote(error(ignore)))
```


# Conclusions

This package expands the possibilities of R\ by allowing calculations and graphical rendition at the same time. This makes it easier for the user to notice writing errors and correct them smoothly. Building on current features of R\ and existing packages for displaying formulas in R\ (e.g. Murrell and Ihaka [-@murrell2000], Allaire et al. [-@allaire2018]), the \pkg{mathml} package bridges the gap between computational needs, presentation of results, and their reproducibility. To do so, it uses the Prolog's grammar rules and translates the R\ expressions to MathML. Then, two possible solutions for typesetting are available to export R\ Markdown documents in different formats or ShinyApp webpages: MathML and MathJax. 

The article and Appendix show examples of how the package can be used and what operations are currently possible. Additionally, \pkg{mathml} allows for user's custom hooks to provide a better definition of the needed functions.


In its current version \pkg{mathml} has some limitations. For example, it is still not possible to use the functions of \pkg{mathml} for writing intratextual formulas, while it is still more convenient to adopt the usual LateX notation. However, we do not consider this to be a serious limitation, since the most productive use of \pkg{mathml} still comes from more complicated calculations. Nevertheless, in the future versions of this package we will address this issue, to broaden its spectrum of possible applications. 


\pkg{mathml} is available for R\ version (…) and later, and can be easily installed using the usual `install.packages("mathml")`. The source code of the package is found at (…) including installation instructions for Unix, Windows and macOS.

# Acknowledgments
 
