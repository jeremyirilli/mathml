---
title: "mathml: Translate R expressions to MathML"
author: "Matthias Gondan (Department of Psychology, University of Innsbruck, Austria)"
date: "2022-04-28"
bibliography: bibliography.bibtex
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rolog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(rmarkdown.html_vignette.check_title=FALSE)
```

  Matthias Gondan\
  Department of Psychology\
  University of Innsbruck\
  Innrain 9\
  A-6020 Innsbruck\
  Matthias.Gondan-Rochon@uibk.ac.at
  
# Abstract

123

## Keywords

HTML; MathML; R

# 1. mathml: Translate R expressions to MathML

The R extension of the markdown language [@Xie2020] enables reproducible
statistical reports with nice typesetting in HTML, Microsoft Word, and Latex.
However, so far, R expressions such as `pbinom(k, N, p)` are typeset as-is; 
prettier mathematical expressions such as $P_\mathrm{Bi}(X \le k; N, p)$ require
Latex commands like `P_\mathrm{Bi}\left(X \le k; N, p\right)`, which are
cumbersome to type in and hard to read even if the expressions are simple.
Since recently, manual pages include support for mathematical 
expressions [@Sarkar2022], which already is a big improvement.

Below Prolog's grammar rules are used for an _automatic_ translation of R
expressions to MathML. The result can then be used for calculations or it can be
rendered on a web page. A limited set of rules for translation from R to MathML
is found in `pl/mathml.pl` of the rolog package. The relevant code snippets are
shown in the listings below, along with their output.

```{r, results="asis"}
library(mathml)

term <- quote(pbinom(k, N, p))
mathml(term)

# Do some calculations with the same term
k = 10
N = 22
p = 0.4
eval(term)

catmath <- function(term)
{
  s <- substitute(term)
  c <- canonical(s)
  mathml(c)
}

catmathjax <- function(term)
{
  s <- substitute(term)
  c <- canonical(s)
  mathjax(c)
}
```

# Package base

```{r, results="asis"}
catmath("text")
catmathjax("text")

catmath(pi)
catmathjax(pi)

catmath(abs(x))
catmathjax(abs(alpha))

catmath(sign(x))
catmathjax(sign(alpha))

catmath(sqrt(2L))
catmathjax(sqrt(alpha))

catmath(sin(pi/2L))
catmathjax(sin(pi/2L))

catmath(cos(pi/2L))
catmathjax(cos(pi/2L))

catmath(tan(pi/2L))
catmathjax(tan(pi/2L))

catmath(asin(1L/2L * sqrt(2L)))
catmathjax(asin(1L/2L * sqrt(2L)))

catmath(acos(1L/2L * sqrt(2L)))
catmathjax(acos(1L/2L * sqrt(2L)))

catmath(atan(1L/2L * sqrt(2L)))
catmathjax(atan(1L/2L * sqrt(2L)))

catmath(atan2(1L, sqrt(3L)))
catmathjax(atan2(1L, sqrt(3L)))

catmath(sinpi(2L))
catmathjax(sinpi(2L))

catmath(cospi(2L))
catmathjax(cospi(2L))

catmath(tanpi(2L))
catmathjax(tanpi(2L))

catmath(sinh(x))
catmathjax(sinh(x))

catmath(cosh(x))
catmathjax(cosh(x))

catmath(tanh(x))
catmathjax(tanh(x))

catmath(asinh(x))
catmathjax(asinh(x))

catmath(acosh(x))
catmathjax(acosh(x))

catmath(atanh(x))
catmathjax(atanh(x))

catmath(all(x))
catmathjax(all(x))

catmath(any(x))
catmathjax(any(x))

catmath(besselI(x, nu))
catmathjax(besselI(x, nu))

catmath(besselK(x, nu))
catmathjax(besselK(x, nu))

catmath(besselJ(x, nu))
catmathjax(besselJ(x, nu))

catmath(besselY(x, nu))
catmathjax(besselY(x, nu))

catmath(beta(a, b))
catmathjax(beta(a, b))

catmath(lbeta(a, b))
catmathjax(lbeta(a, b))

catmath(gamma(x))
catmathjax(gamma(x))

catmath(lgamma(x))
catmathjax(lgamma(x))

catmath(psigamma(x, deriv=psi))
catmathjax(psigamma(x, deriv=psi))

catmath(digamma(x))
catmathjax(digamma(x))

catmath(trigamma(x))
catmathjax(trigamma(x))

catmath(choose(n, k))
catmathjax(choose(n, k))

catmath(choose(k=K, n=N))
catmathjax(choose(k=K, n=N))

catmath(lchoose(n, k))
catmathjax(lchoose(n, k))

catmath(factorial(x))
catmathjax(factorial(x))

catmath(lfactorial(x))
catmathjax(lfactorial(x))

catmath(A & B)
catmathjax(A & B)

catmath(A | B)
catmathjax(A | B)

catmath(!A)
catmathjax(!A)

catmath(xor(A, B))
catmathjax(xor(A, B))

catmath(exp(2L*pi*i))
catmathjax(exp(2L*pi*i))

catmath(expm1(2L*pi*i))
catmathjax(expm1(2L*pi*i))

catmath(log(x))
catmathjax(log(x))

catmath(log10(x))
catmathjax(log10(x))

catmath(log2(x))
catmathjax(log2(x))

catmath(logb(x, e))
catmathjax(logb(x, e))

catmath(log1p(x))
catmathjax(log1p(x))

catmath(ceiling(pi))
catmathjax(ceiling(pi))

catmath(floor(pi))
catmathjax(floor(pi))

f <- function(x) sin(x)
mathml(canonical(f))
mathjax(canonical(f))

catmath(function(x) sin(x))
catmathjax(function(x) sin(x))

catmath(function(x) {sin(x)})
catmathjax(function(x) {sin(x)})

catmath(function(x) {sin(x); cos(x)})
catmathjax(function(x) {sin(x); cos(x)})

catmath(identical(1L, 2L))
catmathjax(identical(1L, 2L))

catmath(ifelse(a > b, a, b))
catmathjax(ifelse(a > b, a, b))

catmath(a %in% A)
catmathjax(a %in% A)

catmath(intersect(A, B))
catmathjax(intersect(A, B))

catmath(union(A, B))
catmathjax(union(A, B))

catmath(is.null(intersect(A, B)))
catmathjax(is.null(intersect(A, B)))

catmath(a:b)
catmathjax(a:b)

catmath(setdiff(A, B))
catmathjax(setdiff(A, B))

catmath(X %x% Y)
catmathjax(X %x% Y)

catmath(a*b + c/d - e %*% f)
catmathjax(a*b + c/d - e %*% f)

catmath(crossprod(A, B))
catmathjax(crossprod(A, B))

catmath(tcrossprod(A, B))
catmathjax(tcrossprod(A, B))

catmath(A ~ B)
catmathjax(A ~ B)

# not the desired result
X <- rnorm(5)
catmath(sum(X))
catmathjax(sum(X))

# this yields the desired result
X <- rnorm(5)
i <- seq_along(X)
catmath(sum(X[i]))
catmathjax(sum(X[i]))

catmath(over(index=i, from=1L, to=N, fun=sum(X[i])))
catmathjax(over(index=i, from=1L, to=N, fun=sum(X[i])))

catmath(L == prod(L[i]))
catmathjax(L == prod(L[i]))

catmath(mean(X) == sum(X[i])/N)
catmathjax(mean(X) == sum(X[i])/N)

catmath(min(X[i]))
catmathjax(min(X[i]))

catmath(max(X[i]))
catmathjax(max(X[i]))

catmath((t(X)*X)^-1L*t(X)*y)
catmathjax((t(X)*X)^-1L*t(X)*y)

N = 20
k = 0:N
alpha = 0.05
catmath(c["lower"] == which.max(pbinom(k, N, pi) <= alpha))
catmathjax(c["lower"] == which.max(pbinom(k, N, pi) <= alpha))

catmath(c["upper"] == which.min(1L-pbinom(k, N, pi) <= alpha))
catmathjax(c["upper"] == which.min(1L-pbinom(k, N, pi) <= alpha))

# todo 0.2: complex numbers, Re, Im
# todo 0.3: sum for k \in calligraphic(K), P(K = k) * pi_K
# todo 0.4: package stats (e.g., integrate)
# todo 0.5: hook for custom functions and macros
# todo 0.6: function bodies
# todo 0.7: case study
# todo 0.8: generate expressions for Rd file
# todo 0.9: RJ paper, see Sarkar2022
```

# References
